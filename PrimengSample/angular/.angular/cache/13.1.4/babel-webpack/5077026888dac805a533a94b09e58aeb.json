{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { ChangeDetectorRef, Component, Input, InjectionToken, Injectable, Inject, isDevMode, Optional, SkipSelf, Directive, EventEmitter, Output, Self, Injector, Pipe, NgModule, APP_INITIALIZER, LOCALE_ID, NgModuleFactory, Compiler, ComponentFactoryResolver, ApplicationRef, inject } from '@angular/core';\nimport * as i1$1 from '@angular/router';\nimport { PRIMARY_OUTLET, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, ActivatedRoute, Router, RouterModule } from '@angular/router';\nimport { BehaviorSubject, Subject, throwError, Subscription, combineLatest, from, fromEvent, ReplaySubject, of, timer, pipe, Observable, concat } from 'rxjs';\nimport { map, distinctUntilChanged, filter, catchError, switchMap, take, mapTo, debounceTime, takeUntil, tap, finalize, retryWhen, delay, shareReplay } from 'rxjs/operators';\nimport compare from 'just-compare';\nimport { __rest, __awaiter } from 'tslib';\nimport * as i1 from '@angular/common/http';\nimport { HttpParams, HttpHeaders, HttpClient, HttpClientModule, HttpClientXsrfModule, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport * as i5 from '@angular/common';\nimport { registerLocaleData, DOCUMENT, DatePipe, DATE_PIPE_DEFAULT_TIMEZONE, CommonModule } from '@angular/common';\nimport * as i1$2 from '@angular/forms';\nimport { FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';\nimport * as i1$3 from 'angular-oauth2-oidc';\nimport { OAuthStorage, OAuthService, OAuthErrorEvent, OAuthInfoEvent, OAuthModule } from 'angular-oauth2-oidc';\nimport clone from 'just-clone'; // Not an abstract class on purpose. Do not change!\n\nfunction DynamicLayoutComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, 1);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngComponentOutlet\", ctx_r0.layout);\n  }\n}\n\nfunction ReplaceableRouteContainerComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nlet AbstractNgModelComponent = /*#__PURE__*/(() => {\n  class AbstractNgModelComponent {\n    constructor(injector) {\n      this.injector = injector;\n\n      this.valueFn = value => value;\n\n      this.valueLimitFn = value => false;\n\n      this.cdRef = injector.get(ChangeDetectorRef);\n    }\n\n    set value(value) {\n      value = this.valueFn(value, this._value);\n      if (this.valueLimitFn(value, this._value) !== false || this.readonly) return;\n      this._value = value;\n      this.notifyValueChange();\n    }\n\n    get value() {\n      return this._value || this.defaultValue;\n    }\n\n    get defaultValue() {\n      return this._value;\n    }\n\n    notifyValueChange() {\n      if (this.onChange) {\n        this.onChange(this.value);\n      }\n    }\n\n    writeValue(value) {\n      this._value = this.valueLimitFn(value, this._value) || value;\n      setTimeout(() => this.cdRef.markForCheck(), 0);\n    }\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n\n  }\n\n  AbstractNgModelComponent.ɵfac = function AbstractNgModelComponent_Factory(t) {\n    return new (t || AbstractNgModelComponent)(i0.ɵɵdirectiveInject(i0.Injector));\n  };\n\n  AbstractNgModelComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: AbstractNgModelComponent,\n    selectors: [[\"ng-component\"]],\n    inputs: {\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      valueFn: \"valueFn\",\n      valueLimitFn: \"valueLimitFn\",\n      value: \"value\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function AbstractNgModelComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return AbstractNgModelComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction pushValueTo(array) {\n  return element => {\n    array.push(element);\n    return array;\n  };\n}\n/* eslint-disable @typescript-eslint/ban-types */\n\n\nclass BaseTreeNode {\n  constructor(props) {\n    this.children = [];\n    this.isLeaf = true;\n    Object.assign(this, props);\n  }\n\n  static create(props) {\n    return new BaseTreeNode(props);\n  }\n\n}\n\nfunction createTreeFromList(list, keySelector, parentKeySelector, valueMapper) {\n  const map = createMapFromList(list, keySelector, valueMapper);\n  const tree = [];\n  list.forEach(row => {\n    const id = keySelector(row);\n    const parentId = parentKeySelector(row);\n    const node = map.get(id);\n    if (!node) return;\n\n    if (parentId) {\n      const parent = map.get(parentId);\n      if (!parent) return;\n      parent.children.push(node);\n      parent.isLeaf = false;\n      node.parent = parent;\n    } else {\n      tree.push(node);\n    }\n  });\n  return tree;\n}\n\nfunction createMapFromList(list, keySelector, valueMapper) {\n  const map = new Map();\n  list.forEach(row => map.set(keySelector(row), valueMapper(row)));\n  return map;\n}\n\nfunction createTreeNodeFilterCreator(key, mapperFn) {\n  return search => {\n    const regex = new RegExp('.*' + search + '.*', 'i');\n    return function collectNodes(nodes, matches = []) {\n      for (const node of nodes) {\n        if (regex.test(mapperFn(node[key]))) matches.push(node);\n        if (node.children.length) collectNodes(node.children, matches);\n      }\n\n      return matches;\n    };\n  };\n}\n\nfunction noop() {\n  const fn = function () {};\n\n  return fn;\n}\n\nfunction isUndefinedOrEmptyString(value) {\n  return value === undefined || value === '';\n}\n\nfunction isNullOrUndefined(obj) {\n  return obj === null || obj === undefined;\n}\n\nfunction exists(obj) {\n  return !isNullOrUndefined(obj);\n}\n\nfunction isObject(obj) {\n  return obj instanceof Object;\n}\n\nfunction isArray(obj) {\n  return Array.isArray(obj);\n}\n\nfunction isObjectAndNotArray(obj) {\n  return isObject(obj) && !isArray(obj);\n}\n\nfunction isNode(obj) {\n  return obj instanceof Node;\n}\n\nfunction isObjectAndNotArrayNotNode(obj) {\n  return isObjectAndNotArray(obj) && !isNode(obj);\n}\n\nfunction deepMerge(target, source) {\n  if (isObjectAndNotArrayNotNode(target) && isObjectAndNotArrayNotNode(source)) {\n    return deepMergeRecursively(target, source);\n  } else if (isNullOrUndefined(target) && isNullOrUndefined(source)) {\n    return {};\n  } else {\n    return exists(source) ? source : target;\n  }\n}\n\nfunction deepMergeRecursively(target, source) {\n  const shouldNotRecurse = isNullOrUndefined(target) || isNullOrUndefined(source) || // at least one not defined\n  isArray(target) || isArray(source) || // at least one array\n  !isObject(target) || !isObject(source) || // at least one not an object\n  isNode(target) || isNode(source); // at least one node\n\n  /**\r\n   * if we will not recurse any further,\r\n   * we will prioritize source if it is a defined value.\r\n   */\n\n  if (shouldNotRecurse) {\n    return exists(source) ? source : target;\n  }\n\n  const keysOfTarget = Object.keys(target);\n  const keysOfSource = Object.keys(source);\n  const uniqueKeys = new Set(keysOfTarget.concat(keysOfSource));\n  return [...uniqueKeys].reduce((retVal, key) => {\n    retVal[key] = deepMergeRecursively(target[key], source[key]);\n    return retVal;\n  }, {});\n}\n\nclass InternalStore {\n  constructor(initialState) {\n    this.initialState = initialState;\n    this.state$ = new BehaviorSubject(this.initialState);\n    this.update$ = new Subject();\n\n    this.sliceState = (selector, compareFn = compare) => this.state$.pipe(map(selector), distinctUntilChanged(compareFn));\n\n    this.sliceUpdate = (selector, filterFn = x => x !== undefined) => this.update$.pipe(map(selector), filter(filterFn));\n  }\n\n  get state() {\n    return this.state$.value;\n  }\n\n  patch(state) {\n    let patchedState = state;\n\n    if (typeof state === 'object' && !Array.isArray(state)) {\n      patchedState = Object.assign(Object.assign({}, this.state), state);\n    }\n\n    this.state$.next(patchedState);\n    this.update$.next(patchedState);\n  }\n\n  deepPatch(state) {\n    this.state$.next(deepMerge(this.state, state));\n    this.update$.next(state);\n  }\n\n  set(state) {\n    this.state$.next(state);\n    this.update$.next(state);\n  }\n\n  reset() {\n    this.set(this.initialState);\n  }\n\n}\n\nconst CORE_OPTIONS = new InjectionToken('CORE_OPTIONS');\n\nfunction coreOptionsFactory(_a) {\n  var options = __rest(_a, []);\n\n  return Object.assign({}, options);\n}\n\nconst mapToApiUrl = key => apis => (apis[key] || apis.default).url || apis.default.url;\n\nconst mapToIssuer = issuer => {\n  if (!issuer) {\n    return issuer;\n  }\n\n  return issuer.endsWith('/') ? issuer : issuer + '/';\n};\n\nlet EnvironmentService = /*#__PURE__*/(() => {\n  class EnvironmentService {\n    constructor() {\n      this.store = new InternalStore({});\n    }\n\n    get createOnUpdateStream() {\n      return this.store.sliceUpdate;\n    }\n\n    getEnvironment$() {\n      return this.store.sliceState(state => state);\n    }\n\n    getEnvironment() {\n      return this.store.state;\n    }\n\n    getApiUrl(key) {\n      return mapToApiUrl(key)(this.store.state.apis);\n    }\n\n    getApiUrl$(key) {\n      return this.store.sliceState(state => state.apis).pipe(map(mapToApiUrl(key)));\n    }\n\n    setState(environment) {\n      this.store.set(environment);\n    }\n\n    getIssuer() {\n      const issuer = this.store.state.oAuthConfig.issuer;\n      return mapToIssuer(issuer);\n    }\n\n    getIssuer$() {\n      return this.store.sliceState(state => state.oAuthConfig.issuer).pipe(map(mapToIssuer));\n    }\n\n  }\n\n  EnvironmentService.ɵfac = function EnvironmentService_Factory(t) {\n    return new (t || EnvironmentService)();\n  };\n\n  EnvironmentService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: EnvironmentService,\n    factory: EnvironmentService.ɵfac,\n    providedIn: 'root'\n  });\n  return EnvironmentService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet HttpErrorReporterService = /*#__PURE__*/(() => {\n  class HttpErrorReporterService {\n    constructor() {\n      this._reporter$ = new Subject();\n      this._errors$ = new BehaviorSubject([]);\n\n      this.reportError = error => {\n        this._reporter$.next(error);\n\n        this._errors$.next([...this.errors, error]);\n      };\n    }\n\n    get reporter$() {\n      return this._reporter$.asObservable();\n    }\n\n    get errors$() {\n      return this._errors$.asObservable();\n    }\n\n    get errors() {\n      return this._errors$.value;\n    }\n\n  }\n\n  HttpErrorReporterService.ɵfac = function HttpErrorReporterService_Factory(t) {\n    return new (t || HttpErrorReporterService)();\n  };\n\n  HttpErrorReporterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: HttpErrorReporterService,\n    factory: HttpErrorReporterService.ɵfac,\n    providedIn: 'root'\n  });\n  return HttpErrorReporterService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RestService = /*#__PURE__*/(() => {\n  class RestService {\n    constructor(options, http, environment, httpErrorReporter) {\n      this.options = options;\n      this.http = http;\n      this.environment = environment;\n      this.httpErrorReporter = httpErrorReporter;\n    }\n\n    getApiFromStore(apiName) {\n      return this.environment.getApiUrl(apiName);\n    }\n\n    handleError(err) {\n      this.httpErrorReporter.reportError(err);\n      return throwError(err);\n    }\n\n    request(request, config, api) {\n      config = config || {};\n      api = api || this.getApiFromStore(config.apiName);\n\n      const {\n        method,\n        params\n      } = request,\n            options = __rest(request, [\"method\", \"params\"]);\n\n      const {\n        observe = \"body\"\n        /* Body */\n        ,\n        skipHandleError\n      } = config;\n      const url = this.removeDuplicateSlashes(api + request.url);\n      return this.http.request(method, url, Object.assign(Object.assign({\n        observe\n      }, params && {\n        params: this.getParams(params, config.httpParamEncoder)\n      }), options)).pipe(catchError(err => skipHandleError ? throwError(err) : this.handleError(err)));\n    }\n\n    getParams(params, encoder) {\n      const filteredParams = Object.keys(params).reduce((acc, key) => {\n        const value = params[key];\n        if (isUndefinedOrEmptyString(value)) return acc;\n        if (value === null && !this.options.sendNullsAsQueryParam) return acc;\n        acc[key] = value;\n        return acc;\n      }, {});\n      return encoder ? new HttpParams({\n        encoder,\n        fromObject: filteredParams\n      }) : new HttpParams({\n        fromObject: filteredParams\n      });\n    }\n\n    removeDuplicateSlashes(url) {\n      return url.replace(/([^:]\\/)\\/+/g, '$1');\n    }\n\n  }\n\n  RestService.ɵfac = function RestService_Factory(t) {\n    return new (t || RestService)(i0.ɵɵinject(CORE_OPTIONS), i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(EnvironmentService), i0.ɵɵinject(HttpErrorReporterService));\n  };\n\n  RestService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RestService,\n    factory: RestService.ɵfac,\n    providedIn: 'root'\n  });\n  return RestService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AbpApplicationConfigurationService = /*#__PURE__*/(() => {\n  class AbpApplicationConfigurationService {\n    constructor(restService) {\n      this.restService = restService;\n      this.apiName = 'abp';\n\n      this.get = () => this.restService.request({\n        method: 'GET',\n        url: '/api/abp/application-configuration'\n      }, {\n        apiName: this.apiName\n      });\n    }\n\n  }\n\n  AbpApplicationConfigurationService.ɵfac = function AbpApplicationConfigurationService_Factory(t) {\n    return new (t || AbpApplicationConfigurationService)(i0.ɵɵinject(RestService));\n  };\n\n  AbpApplicationConfigurationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AbpApplicationConfigurationService,\n    factory: AbpApplicationConfigurationService.ɵfac,\n    providedIn: 'root'\n  });\n  return AbpApplicationConfigurationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ConfigStateService = /*#__PURE__*/(() => {\n  class ConfigStateService {\n    constructor(abpConfigService) {\n      this.abpConfigService = abpConfigService;\n      this.store = new InternalStore({});\n      this.updateSubject = new Subject();\n      this.initUpdateStream();\n    }\n\n    get createOnUpdateStream() {\n      return this.store.sliceUpdate;\n    }\n\n    initUpdateStream() {\n      this.updateSubject.pipe(switchMap(() => this.abpConfigService.get())).subscribe(res => this.store.set(res));\n    }\n\n    refreshAppState() {\n      this.updateSubject.next();\n      return this.createOnUpdateStream(state => state).pipe(take(1));\n    }\n\n    getOne$(key) {\n      return this.store.sliceState(state => state[key]);\n    }\n\n    getOne(key) {\n      return this.store.state[key];\n    }\n\n    getAll$() {\n      return this.store.sliceState(state => state);\n    }\n\n    getAll() {\n      return this.store.state;\n    }\n\n    getDeep$(keys) {\n      keys = splitKeys(keys);\n      return this.store.sliceState(state => state).pipe(map(state => {\n        return keys.reduce((acc, val) => {\n          if (acc) {\n            return acc[val];\n          }\n\n          return undefined;\n        }, state);\n      }));\n    }\n\n    getDeep(keys) {\n      keys = splitKeys(keys);\n      return keys.reduce((acc, val) => {\n        if (acc) {\n          return acc[val];\n        }\n\n        return undefined;\n      }, this.store.state);\n    }\n\n    getFeature(key) {\n      var _a, _b;\n\n      return (_b = (_a = this.store.state.features) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b[key];\n    }\n\n    getFeature$(key) {\n      return this.store.sliceState(state => {\n        var _a, _b;\n\n        return (_b = (_a = state.features) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b[key];\n      });\n    }\n\n    getFeatures(keys) {\n      const {\n        features\n      } = this.store.state;\n      if (!features) return;\n      return keys.reduce((acc, key) => Object.assign(Object.assign({}, acc), {\n        [key]: features.values[key]\n      }), {});\n    }\n\n    getFeatures$(keys) {\n      return this.store.sliceState(({\n        features\n      }) => {\n        if (!(features === null || features === void 0 ? void 0 : features.values)) return;\n        return keys.reduce((acc, key) => Object.assign(Object.assign({}, acc), {\n          [key]: features.values[key]\n        }), {});\n      });\n    }\n\n    getSetting(key) {\n      var _a, _b;\n\n      return (_b = (_a = this.store.state.setting) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b[key];\n    }\n\n    getSetting$(key) {\n      return this.store.sliceState(state => {\n        var _a, _b;\n\n        return (_b = (_a = state.setting) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b[key];\n      });\n    }\n\n    getSettings(keyword) {\n      var _a;\n\n      const settings = ((_a = this.store.state.setting) === null || _a === void 0 ? void 0 : _a.values) || {};\n      if (!keyword) return settings;\n      const keysFound = Object.keys(settings).filter(key => key.indexOf(keyword) > -1);\n      return keysFound.reduce((acc, key) => {\n        acc[key] = settings[key];\n        return acc;\n      }, {});\n    }\n\n    getSettings$(keyword) {\n      return this.store.sliceState(state => {\n        var _a;\n\n        return (_a = state.setting) === null || _a === void 0 ? void 0 : _a.values;\n      }).pipe(map((settings = {}) => {\n        if (!keyword) return settings;\n        const keysFound = Object.keys(settings).filter(key => key.indexOf(keyword) > -1);\n        return keysFound.reduce((acc, key) => {\n          acc[key] = settings[key];\n          return acc;\n        }, {});\n      }));\n    }\n\n    getGlobalFeatures() {\n      return this.store.state.globalFeatures;\n    }\n\n    getGlobalFeatures$() {\n      return this.store.sliceState(state => state.globalFeatures);\n    }\n\n    isGlobalFeatureEnabled(key, globalFeatures) {\n      const features = globalFeatures.enabledFeatures || [];\n      return features.some(f => key === f);\n    }\n\n    getGlobalFeatureIsEnabled(key) {\n      return this.isGlobalFeatureEnabled(key, this.store.state.globalFeatures);\n    }\n\n    getGlobalFeatureIsEnabled$(key) {\n      return this.store.sliceState(state => this.isGlobalFeatureEnabled(key, state.globalFeatures));\n    }\n\n  }\n\n  ConfigStateService.ɵfac = function ConfigStateService_Factory(t) {\n    return new (t || ConfigStateService)(i0.ɵɵinject(AbpApplicationConfigurationService));\n  };\n\n  ConfigStateService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ConfigStateService,\n    factory: ConfigStateService.ɵfac,\n    providedIn: 'root'\n  });\n  return ConfigStateService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction splitKeys(keys) {\n  if (typeof keys === 'string') {\n    keys = keys.split('.');\n  }\n\n  if (!Array.isArray(keys)) {\n    throw new Error('The argument must be a dot string or an string array.');\n  }\n\n  return keys;\n}\n\nlet PermissionService = /*#__PURE__*/(() => {\n  class PermissionService {\n    constructor(configState) {\n      this.configState = configState;\n    }\n\n    getGrantedPolicy$(key) {\n      return this.getStream().pipe(map(grantedPolicies => this.isPolicyGranted(key, grantedPolicies)));\n    }\n\n    getGrantedPolicy(key) {\n      const policies = this.getSnapshot();\n      return this.isPolicyGranted(key, policies);\n    }\n\n    filterItemsByPolicy(items) {\n      const policies = this.getSnapshot();\n      return items.filter(item => !item.requiredPolicy || this.isPolicyGranted(item.requiredPolicy, policies));\n    }\n\n    filterItemsByPolicy$(items) {\n      return this.getStream().pipe(map(policies => items.filter(item => !item.requiredPolicy || this.isPolicyGranted(item.requiredPolicy, policies))));\n    }\n\n    isPolicyGranted(key, grantedPolicies) {\n      if (!key) return true;\n      const orRegexp = /\\|\\|/g;\n      const andRegexp = /&&/g; // TODO: Allow combination of ANDs & ORs\n\n      if (orRegexp.test(key)) {\n        const keys = key.split('||').filter(Boolean);\n        if (keys.length < 2) return false;\n        return keys.some(k => this.getPolicy(k.trim(), grantedPolicies));\n      } else if (andRegexp.test(key)) {\n        const keys = key.split('&&').filter(Boolean);\n        if (keys.length < 2) return false;\n        return keys.every(k => this.getPolicy(k.trim(), grantedPolicies));\n      }\n\n      return this.getPolicy(key, grantedPolicies);\n    }\n\n    getStream() {\n      return this.configState.getAll$().pipe(map(this.mapToPolicies));\n    }\n\n    getSnapshot() {\n      return this.mapToPolicies(this.configState.getAll());\n    }\n\n    mapToPolicies(applicationConfiguration) {\n      var _a;\n\n      return ((_a = applicationConfiguration === null || applicationConfiguration === void 0 ? void 0 : applicationConfiguration.auth) === null || _a === void 0 ? void 0 : _a.grantedPolicies) || {};\n    }\n\n    getPolicy(key, grantedPolicies) {\n      return grantedPolicies[key] || false;\n    }\n\n  }\n\n  PermissionService.ɵfac = function PermissionService_Factory(t) {\n    return new (t || PermissionService)(i0.ɵɵinject(ConfigStateService));\n  };\n\n  PermissionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PermissionService,\n    factory: PermissionService.ɵfac,\n    providedIn: 'root'\n  });\n  return PermissionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nclass AbstractTreeService {\n  constructor() {\n    this._flat$ = new BehaviorSubject([]);\n    this._tree$ = new BehaviorSubject([]);\n    this._visible$ = new BehaviorSubject([]);\n  }\n\n  get flat() {\n    return this._flat$.value;\n  }\n\n  get flat$() {\n    return this._flat$.asObservable();\n  }\n\n  get tree() {\n    return this._tree$.value;\n  }\n\n  get tree$() {\n    return this._tree$.asObservable();\n  }\n\n  get visible() {\n    return this._visible$.value;\n  }\n\n  get visible$() {\n    return this._visible$.asObservable();\n  }\n\n  createTree(items) {\n    return createTreeFromList(items, item => item[this.id], item => item[this.parentId], item => BaseTreeNode.create(item));\n  }\n\n  filterWith(setOrMap) {\n    return this._flat$.value.filter(item => !setOrMap.has(item[this.id]));\n  }\n\n  findItemsToRemove(set) {\n    return this._flat$.value.reduce((acc, item) => {\n      if (!acc.has(item[this.parentId])) return acc;\n      const childSet = new Set([item[this.id]]);\n      const children = this.findItemsToRemove(childSet);\n      return new Set([...acc, ...children]);\n    }, set);\n  }\n\n  publish(flatItems, visibleItems) {\n    this._flat$.next(flatItems);\n\n    this._tree$.next(this.createTree(flatItems));\n\n    this._visible$.next(this.createTree(visibleItems));\n\n    return flatItems;\n  }\n\n  add(items) {\n    const map = new Map();\n    items.forEach(item => map.set(item[this.id], item));\n    const flatItems = this.filterWith(map);\n    map.forEach(pushValueTo(flatItems));\n    flatItems.sort(this.sort);\n    const visibleItems = flatItems.filter(item => !this.hide(item));\n    return this.publish(flatItems, visibleItems);\n  }\n\n  find(predicate, tree = this.tree) {\n    return tree.reduce((acc, node) => acc ? acc : predicate(node) ? node : this.find(predicate, node.children), null);\n  }\n\n  patch(identifier, props) {\n    const flatItems = this._flat$.value;\n    const index = flatItems.findIndex(item => item[this.id] === identifier);\n    if (index < 0) return false;\n    flatItems[index] = Object.assign(Object.assign({}, flatItems[index]), props);\n    flatItems.sort(this.sort);\n    const visibleItems = flatItems.filter(item => !this.hide(item));\n    return this.publish(flatItems, visibleItems);\n  }\n\n  refresh() {\n    return this.add([]);\n  }\n\n  remove(identifiers) {\n    const set = new Set();\n    identifiers.forEach(id => set.add(id));\n    const setToRemove = this.findItemsToRemove(set);\n    const flatItems = this.filterWith(setToRemove);\n    const visibleItems = flatItems.filter(item => !this.hide(item));\n    return this.publish(flatItems, visibleItems);\n  }\n\n  search(params, tree = this.tree) {\n    const searchKeys = Object.keys(params);\n    return tree.reduce((acc, node) => acc ? acc : searchKeys.every(key => node[key] === params[key]) ? node : this.search(params, node.children), null);\n  }\n\n}\n\nlet AbstractNavTreeService = /*#__PURE__*/(() => {\n  class AbstractNavTreeService extends AbstractTreeService {\n    constructor(injector) {\n      super();\n      this.injector = injector;\n      this.id = 'name';\n      this.parentId = 'parentName';\n\n      this.hide = item => item.invisible || !this.isGranted(item);\n\n      this.sort = (a, b) => {\n        if (!Number.isInteger(a.order)) return 1;\n        if (!Number.isInteger(b.order)) return -1;\n        return a.order - b.order;\n      };\n\n      const configState = this.injector.get(ConfigStateService);\n      this.subscription = configState.createOnUpdateStream(state => state).subscribe(() => this.refresh());\n      this.permissionService = injector.get(PermissionService);\n    }\n\n    isGranted({\n      requiredPolicy\n    }) {\n      return this.permissionService.getGrantedPolicy(requiredPolicy);\n    }\n\n    hasChildren(identifier) {\n      var _a;\n\n      const node = this.find(item => item[this.id] === identifier);\n      return Boolean((_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.length);\n    }\n\n    hasInvisibleChild(identifier) {\n      var _a;\n\n      const node = this.find(item => item[this.id] === identifier);\n      return (_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.some(child => child.invisible);\n    }\n    /* istanbul ignore next */\n\n\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n\n  }\n\n  AbstractNavTreeService.ɵfac = function AbstractNavTreeService_Factory(t) {\n    return new (t || AbstractNavTreeService)(i0.ɵɵinject(i0.Injector));\n  };\n\n  AbstractNavTreeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AbstractNavTreeService,\n    factory: AbstractNavTreeService.ɵfac\n  });\n  return AbstractNavTreeService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RoutesService = /*#__PURE__*/(() => {\n  class RoutesService extends AbstractNavTreeService {}\n\n  RoutesService.ɵfac = /* @__PURE__ */function () {\n    let ɵRoutesService_BaseFactory;\n    return function RoutesService_Factory(t) {\n      return (ɵRoutesService_BaseFactory || (ɵRoutesService_BaseFactory = i0.ɵɵgetInheritedFactory(RoutesService)))(t || RoutesService);\n    };\n  }();\n\n  RoutesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RoutesService,\n    factory: RoutesService.ɵfac,\n    providedIn: 'root'\n  });\n  return RoutesService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet SubscriptionService = /*#__PURE__*/(() => {\n  class SubscriptionService {\n    constructor() {\n      this.subscription = new Subscription();\n    }\n\n    get isClosed() {\n      return this.subscription.closed;\n    }\n\n    addOne(source$, nextOrObserver, error) {\n      const subscription = source$.subscribe(nextOrObserver, error);\n      this.subscription.add(subscription);\n      return subscription;\n    }\n\n    closeAll() {\n      this.subscription.unsubscribe();\n    }\n\n    closeOne(subscription) {\n      this.removeOne(subscription);\n      subscription.unsubscribe();\n    }\n\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n\n    removeOne(subscription) {\n      if (!subscription) return;\n      this.subscription.remove(subscription);\n    }\n\n    reset() {\n      this.subscription.unsubscribe();\n      this.subscription = new Subscription();\n    }\n\n  }\n\n  SubscriptionService.ɵfac = function SubscriptionService_Factory(t) {\n    return new (t || SubscriptionService)();\n  };\n\n  SubscriptionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SubscriptionService,\n    factory: SubscriptionService.ɵfac\n  });\n  return SubscriptionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction findRoute(routesService, path) {\n  const node = routesService.find(route => route.path === path);\n  return node || path === '/' ? node : findRoute(routesService, path.split('/').slice(0, -1).join('/') || '/');\n}\n\nfunction getRoutePath(router, url = router.url) {\n  const emptyGroup = {\n    segments: []\n  };\n  const primaryGroup = router.parseUrl(url).root.children[PRIMARY_OUTLET];\n  return '/' + (primaryGroup || emptyGroup).segments.map(({\n    path\n  }) => path).join('/');\n}\n\nfunction reloadRoute(router, ngZone) {\n  const {\n    shouldReuseRoute\n  } = router.routeReuseStrategy;\n\n  const setRouteReuse = reuse => {\n    router.routeReuseStrategy.shouldReuseRoute = reuse;\n  };\n\n  setRouteReuse(() => false);\n  router.navigated = false;\n  ngZone.run(() => __awaiter(this, void 0, void 0, function* () {\n    yield router.navigateByUrl(router.url).catch(noop);\n    setRouteReuse(shouldReuseRoute);\n  }));\n}\n\nconst LOCALIZATIONS = new InjectionToken('LOCALIZATIONS');\n\nfunction localizationContributor(localizations) {\n  if (localizations) {\n    localizations$.next([...localizations$.value, ...localizations]);\n  }\n}\n\nconst localizations$ = new BehaviorSubject([]); // This will not be necessary when only Angukar 9.1+ is supported\n\nfunction getLocaleDirection(locale) {\n  return /^(ar(-[A-Z]{2})?|ckb(-IR)?|fa(-AF)?|he|ks|lrc(-IQ)?|mzn|pa-Arab|ps(-PK)?|sd|ug|ur(-IN)?|uz-Arab|yi)$/.test(locale) ? 'rtl' : 'ltr';\n}\n\nfunction createLocalizer(localization) {\n  return (resourceName, key, defaultValue) => {\n    var _a;\n\n    if (resourceName === '_') return key;\n    const resource = (_a = localization === null || localization === void 0 ? void 0 : localization.values) === null || _a === void 0 ? void 0 : _a[resourceName];\n    if (!resource) return defaultValue;\n    return resource[key] || defaultValue;\n  };\n}\n\nfunction createLocalizerWithFallback(localization) {\n  const findLocalization = createLocalizationFinder(localization);\n  return (resourceNames, keys, defaultValue) => {\n    const {\n      localized\n    } = findLocalization(resourceNames, keys);\n    return localized || defaultValue;\n  };\n}\n\nfunction createLocalizationPipeKeyGenerator(localization) {\n  const findLocalization = createLocalizationFinder(localization);\n  return (resourceNames, keys, defaultKey) => {\n    const {\n      resourceName,\n      key\n    } = findLocalization(resourceNames, keys);\n    return !resourceName ? defaultKey : resourceName === '_' ? key : `${resourceName}::${key}`;\n  };\n}\n\nfunction createLocalizationFinder(localization) {\n  const localize = createLocalizer(localization);\n  return (resourceNames, keys) => {\n    resourceNames = resourceNames.concat(localization.defaultResourceName || '').filter(Boolean);\n    const resourceCount = resourceNames.length;\n    const keyCount = keys.length;\n\n    for (let i = 0; i < resourceCount; i++) {\n      const resourceName = resourceNames[i];\n\n      for (let j = 0; j < keyCount; j++) {\n        const key = keys[j];\n        const localized = localize(resourceName, key, null);\n        if (localized) return {\n          resourceName,\n          key,\n          localized\n        };\n      }\n    }\n\n    return {\n      resourceName: undefined,\n      key: undefined,\n      localized: undefined\n    };\n  };\n}\n\nfunction createTokenParser(format) {\n  return str => {\n    const tokens = [];\n    const regex = format.replace(/\\./g, '\\\\.').replace(/\\{\\s?([0-9a-zA-Z]+)\\s?\\}/g, (_, token) => {\n      tokens.push(token);\n      return '(.+)';\n    });\n    const matches = (str.match(regex) || []).slice(1);\n    return matches.reduce((acc, v, i) => {\n      const key = tokens[i];\n      acc[key] = [...(acc[key] || []), v].filter(Boolean);\n      return acc;\n    }, {});\n  };\n}\n\nfunction interpolate(text, params) {\n  return text.replace(/(['\"]?\\{\\s*(\\d+)\\s*\\}['\"]?)/g, (_, match, digit) => {\n    var _a;\n\n    return (_a = params[digit]) !== null && _a !== void 0 ? _a : match;\n  }).replace(/\\s+/g, ' ');\n}\n\nfunction escapeHtmlChars(value) {\n  return value && typeof value === 'string' ? value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;') : value;\n}\n\nlet SessionStateService = /*#__PURE__*/(() => {\n  class SessionStateService {\n    constructor(configState) {\n      this.configState = configState;\n      this.store = new InternalStore({});\n\n      this.updateLocalStorage = () => {\n        localStorage.setItem('abpSession', JSON.stringify(this.store.state));\n      };\n\n      this.init();\n      this.setInitialLanguage();\n    }\n\n    init() {\n      const session = localStorage.getItem('abpSession');\n\n      if (session) {\n        this.store.set(JSON.parse(session));\n      }\n\n      this.store.sliceUpdate(state => state).subscribe(this.updateLocalStorage);\n    }\n\n    setInitialLanguage() {\n      if (this.getLanguage()) return;\n      this.configState.getDeep$('localization.currentCulture.cultureName').pipe(filter(cultureName => !!cultureName), take(1)).subscribe(lang => {\n        if (lang.includes(';')) {\n          lang = lang.split(';')[0];\n        }\n\n        this.setLanguage(lang);\n      });\n    }\n\n    onLanguageChange$() {\n      return this.store.sliceUpdate(state => state.language);\n    }\n\n    onTenantChange$() {\n      return this.store.sliceUpdate(state => state.tenant);\n    }\n\n    getLanguage() {\n      return this.store.state.language;\n    }\n\n    getLanguage$() {\n      return this.store.sliceState(state => state.language);\n    }\n\n    getTenant() {\n      return this.store.state.tenant;\n    }\n\n    getTenant$() {\n      return this.store.sliceState(state => state.tenant);\n    }\n\n    setTenant(tenant) {\n      if (compare(tenant, this.store.state.tenant)) return;\n      this.store.set(Object.assign(Object.assign({}, this.store.state), {\n        tenant\n      }));\n    }\n\n    setLanguage(language) {\n      if (language === this.store.state.language) return;\n      this.store.patch({\n        language\n      });\n      document.documentElement.setAttribute('lang', language);\n    }\n\n  }\n\n  SessionStateService.ɵfac = function SessionStateService_Factory(t) {\n    return new (t || SessionStateService)(i0.ɵɵinject(ConfigStateService));\n  };\n\n  SessionStateService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SessionStateService,\n    factory: SessionStateService.ɵfac,\n    providedIn: 'root'\n  });\n  return SessionStateService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LocalizationService = /*#__PURE__*/(() => {\n  class LocalizationService {\n    constructor(sessionState, injector, otherInstance, configState) {\n      this.sessionState = sessionState;\n      this.injector = injector;\n      this.configState = configState;\n      this.latestLang = this.sessionState.getLanguage();\n      this._languageChange$ = new Subject();\n      this.uiLocalizations$ = new BehaviorSubject(new Map());\n      this.localizations$ = new BehaviorSubject(new Map());\n      if (otherInstance) throw new Error('LocalizationService should have only one instance.');\n      this.listenToSetLanguage();\n      this.initLocalizationValues();\n    }\n    /**\r\n     * Returns currently selected language\r\n     * Even though this looks like it's redundant to return the same value as `getLanguage()`,\r\n     * it's actually not. This could be invoked any time, and the latestLang could be different from the\r\n     * sessionState.getLanguage() value.\r\n     */\n\n\n    get currentLang() {\n      return this.latestLang || this.sessionState.getLanguage();\n    }\n\n    get currentLang$() {\n      return this.sessionState.getLanguage$();\n    }\n\n    get languageChange$() {\n      return this._languageChange$.asObservable();\n    }\n\n    initLocalizationValues() {\n      localizations$.subscribe(val => this.addLocalization(val));\n      const remoteLocalizations$ = this.configState.getDeep$('localization.values');\n      const currentLanguage$ = this.sessionState.getLanguage$();\n      const uiLocalizations$ = combineLatest([currentLanguage$, this.uiLocalizations$]).pipe(map(([currentLang, localizations]) => localizations.get(currentLang)));\n      combineLatest([remoteLocalizations$, uiLocalizations$]).pipe(map(([remote, local]) => {\n        if (remote) {\n          if (!local) {\n            local = new Map();\n          }\n\n          Object.entries(remote).forEach(entry => {\n            const resourceName = entry[0];\n            const remoteTexts = entry[1];\n            let resource = local.get(resourceName) || {};\n            resource = Object.assign(Object.assign({}, resource), remoteTexts);\n            local.set(resourceName, resource);\n          });\n        }\n\n        return local;\n      })).subscribe(val => this.localizations$.next(val));\n    }\n\n    addLocalization(localizations) {\n      if (!localizations) return;\n      const localizationMap = this.uiLocalizations$.value;\n      localizations.forEach(loc => {\n        const cultureMap = localizationMap.get(loc.culture) || new Map();\n        loc.resources.forEach(res => {\n          let resource = cultureMap.get(res.resourceName) || {};\n          resource = Object.assign(Object.assign({}, resource), res.texts);\n          cultureMap.set(res.resourceName, resource);\n        });\n        localizationMap.set(loc.culture, cultureMap);\n      });\n      this.uiLocalizations$.next(localizationMap);\n    }\n\n    listenToSetLanguage() {\n      this.sessionState.onLanguageChange$().pipe(filter(lang => this.configState.getDeep('localization.currentCulture.cultureName') !== lang), switchMap(lang => this.configState.refreshAppState().pipe(mapTo(lang))), switchMap(lang => from(this.registerLocale(lang).then(() => lang)))).subscribe(lang => this._languageChange$.next(lang));\n    }\n\n    registerLocale(locale) {\n      const {\n        registerLocaleFn\n      } = this.injector.get(CORE_OPTIONS);\n      return registerLocaleFn(locale).then(module => {\n        if (module === null || module === void 0 ? void 0 : module.default) registerLocaleData(module.default);\n        this.latestLang = locale;\n      });\n    }\n    /**\r\n     * Returns an observable localized text with the given interpolation parameters in current language.\r\n     * @param key Localizaton key to replace with localized text\r\n     * @param interpolateParams Values to interpolate\r\n     */\n\n\n    get(key, ...interpolateParams) {\n      return this.configState.getAll$().pipe(map(state => this.getLocalization(state, key, ...interpolateParams)));\n    }\n\n    getResource(resourceName) {\n      return this.localizations$.value.get(resourceName);\n    }\n\n    getResource$(resourceName) {\n      return this.localizations$.pipe(map(res => res.get(resourceName)));\n    }\n    /**\r\n     * Returns localized text with the given interpolation parameters in current language.\r\n     * @param key Localization key to replace with localized text\r\n     * @param interpolateParams Values to intepolate.\r\n     */\n\n\n    instant(key, ...interpolateParams) {\n      return this.getLocalization(this.configState.getAll(), key, ...interpolateParams);\n    }\n\n    localize(resourceName, key, defaultValue) {\n      return this.configState.getOne$('localization').pipe(map(createLocalizer), map(localize => localize(resourceName, key, defaultValue)));\n    }\n\n    localizeSync(resourceName, key, defaultValue) {\n      const localization = this.configState.getOne('localization');\n      return createLocalizer(localization)(resourceName, key, defaultValue);\n    }\n\n    localizeWithFallback(resourceNames, keys, defaultValue) {\n      return this.configState.getOne$('localization').pipe(map(createLocalizerWithFallback), map(localizeWithFallback => localizeWithFallback(resourceNames, keys, defaultValue)));\n    }\n\n    localizeWithFallbackSync(resourceNames, keys, defaultValue) {\n      const localization = this.configState.getOne('localization');\n      return createLocalizerWithFallback(localization)(resourceNames, keys, defaultValue);\n    }\n\n    getLocalization(state, key, ...interpolateParams) {\n      if (!key) key = '';\n      let defaultValue;\n\n      if (typeof key !== 'string') {\n        defaultValue = key.defaultValue;\n        key = key.key;\n      }\n\n      const keys = key.split('::');\n\n      const warn = message => {\n        if (isDevMode) console.warn(message);\n      };\n\n      if (keys.length < 2) {\n        warn('The localization source separator (::) not found.');\n        return defaultValue || key;\n      }\n\n      if (!state.localization) return defaultValue || keys[1];\n      const sourceName = keys[0] || state.localization.defaultResourceName;\n      const sourceKey = keys[1];\n\n      if (sourceName === '_') {\n        return defaultValue || sourceKey;\n      }\n\n      if (!sourceName) {\n        warn('Localization source name is not specified and the defaultResourceName was not defined!');\n        return defaultValue || sourceKey;\n      }\n\n      const source = this.localizations$.value.get(sourceName);\n\n      if (!source) {\n        warn('Could not find localization source: ' + sourceName);\n        return defaultValue || sourceKey;\n      }\n\n      let localization = source[sourceKey];\n\n      if (typeof localization === 'undefined') {\n        return defaultValue || sourceKey;\n      }\n\n      interpolateParams = interpolateParams.filter(params => params != null);\n      if (localization) localization = interpolate(localization, interpolateParams);\n      if (typeof localization !== 'string') localization = '';\n      return localization || defaultValue || key;\n    }\n\n  }\n\n  LocalizationService.ɵfac = function LocalizationService_Factory(t) {\n    return new (t || LocalizationService)(i0.ɵɵinject(SessionStateService), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(LocalizationService, 12), i0.ɵɵinject(ConfigStateService));\n  };\n\n  LocalizationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LocalizationService,\n    factory: LocalizationService.ɵfac,\n    providedIn: 'root'\n  });\n  return LocalizationService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ReplaceableComponentsService = /*#__PURE__*/(() => {\n  class ReplaceableComponentsService {\n    constructor(ngZone, router) {\n      this.ngZone = ngZone;\n      this.router = router;\n      this.store = new InternalStore([]);\n    }\n\n    get replaceableComponents$() {\n      return this.store.sliceState(state => state);\n    }\n\n    get replaceableComponents() {\n      return this.store.state;\n    }\n\n    get onUpdate$() {\n      return this.store.sliceUpdate(state => state);\n    }\n\n    add(replaceableComponent, reload) {\n      const replaceableComponents = [...this.store.state];\n      const index = replaceableComponents.findIndex(component => component.key === replaceableComponent.key);\n\n      if (index > -1) {\n        replaceableComponents[index] = replaceableComponent;\n      } else {\n        replaceableComponents.push(replaceableComponent);\n      }\n\n      this.store.set(replaceableComponents);\n      if (reload) reloadRoute(this.router, this.ngZone);\n    }\n\n    get(replaceableComponentKey) {\n      return this.replaceableComponents.find(component => component.key === replaceableComponentKey);\n    }\n\n    get$(replaceableComponentKey) {\n      return this.replaceableComponents$.pipe(map(components => components.find(component => component.key === replaceableComponentKey)));\n    }\n\n  }\n\n  ReplaceableComponentsService.ɵfac = function ReplaceableComponentsService_Factory(t) {\n    return new (t || ReplaceableComponentsService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1$1.Router));\n  };\n\n  ReplaceableComponentsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ReplaceableComponentsService,\n    factory: ReplaceableComponentsService.ɵfac,\n    providedIn: 'root'\n  });\n  return ReplaceableComponentsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst NavigationEvent = {\n  Cancel: NavigationCancel,\n  End: NavigationEnd,\n  Error: NavigationError,\n  Start: NavigationStart\n};\nlet RouterEvents = /*#__PURE__*/(() => {\n  class RouterEvents {\n    constructor(router) {\n      this.router = router;\n    }\n\n    getEvents(...eventTypes) {\n      const filterRouterEvents = event => eventTypes.some(type => event instanceof type);\n\n      return this.router.events.pipe(filter(filterRouterEvents));\n    }\n\n    getNavigationEvents(...navigationEventKeys) {\n      const filterNavigationEvents = event => navigationEventKeys.some(key => event instanceof NavigationEvent[key]);\n\n      return this.router.events.pipe(filter(filterNavigationEvents));\n    }\n\n    getAllEvents() {\n      return this.router.events;\n    }\n\n    getAllNavigationEvents() {\n      const keys = Object.keys(NavigationEvent);\n      return this.getNavigationEvents(...keys);\n    }\n\n  }\n\n  RouterEvents.ɵfac = function RouterEvents_Factory(t) {\n    return new (t || RouterEvents)(i0.ɵɵinject(i1$1.Router));\n  };\n\n  RouterEvents.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RouterEvents,\n    factory: RouterEvents.ɵfac,\n    providedIn: 'root'\n  });\n  return RouterEvents;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DynamicLayoutComponent = /*#__PURE__*/(() => {\n  class DynamicLayoutComponent {\n    constructor(injector, localizationService, replaceableComponents, subscription, routerEvents, dynamicLayoutComponent) {\n      this.localizationService = localizationService;\n      this.replaceableComponents = replaceableComponents;\n      this.subscription = subscription;\n      this.routerEvents = routerEvents; // TODO: Consider a shared enum (eThemeSharedComponents) for known layouts\n\n      this.layouts = new Map([['application', 'Theme.ApplicationLayoutComponent'], ['account', 'Theme.AccountLayoutComponent'], ['empty', 'Theme.EmptyLayoutComponent']]);\n      this.isLayoutVisible = true;\n\n      if (dynamicLayoutComponent) {\n        if (isDevMode) console.warn('DynamicLayoutComponent must be used only in AppComponent.');\n        return;\n      }\n\n      this.route = injector.get(ActivatedRoute);\n      this.router = injector.get(Router);\n      this.routes = injector.get(RoutesService);\n      this.checkLayoutOnNavigationEnd();\n      this.listenToLanguageChange();\n    }\n\n    checkLayoutOnNavigationEnd() {\n      const navigationEnd$ = this.routerEvents.getNavigationEvents('End');\n      this.subscription.addOne(navigationEnd$, () => this.getLayout());\n    }\n\n    getLayout() {\n      var _a;\n\n      let expectedLayout = (this.route.snapshot.data || {}).layout;\n\n      if (!expectedLayout) {\n        let node = findRoute(this.routes, getRoutePath(this.router));\n        node = {\n          parent: node\n        };\n\n        while (node.parent) {\n          node = node.parent;\n\n          if (node.layout) {\n            expectedLayout = node.layout;\n            break;\n          }\n        }\n      }\n\n      if (!expectedLayout) expectedLayout = \"empty\"\n      /* empty */\n      ;\n      if (this.layoutKey === expectedLayout) return;\n      const key = this.layouts.get(expectedLayout);\n      this.layout = (_a = this.getComponent(key)) === null || _a === void 0 ? void 0 : _a.component;\n      this.layoutKey = expectedLayout;\n    }\n\n    listenToLanguageChange() {\n      this.subscription.addOne(this.localizationService.languageChange$, () => {\n        this.isLayoutVisible = false;\n        setTimeout(() => this.isLayoutVisible = true, 0);\n      });\n    }\n\n    getComponent(key) {\n      return this.replaceableComponents.get(key);\n    }\n\n  }\n\n  DynamicLayoutComponent.ɵfac = function DynamicLayoutComponent_Factory(t) {\n    return new (t || DynamicLayoutComponent)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(LocalizationService), i0.ɵɵdirectiveInject(ReplaceableComponentsService), i0.ɵɵdirectiveInject(SubscriptionService), i0.ɵɵdirectiveInject(RouterEvents), i0.ɵɵdirectiveInject(DynamicLayoutComponent, 12));\n  };\n\n  DynamicLayoutComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DynamicLayoutComponent,\n    selectors: [[\"abp-dynamic-layout\"]],\n    features: [i0.ɵɵProvidersFeature([SubscriptionService])],\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"ngComponentOutlet\", 4, \"ngIf\"], [3, \"ngComponentOutlet\"]],\n    template: function DynamicLayoutComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, DynamicLayoutComponent_ng_container_0_Template, 1, 1, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.isLayoutVisible);\n      }\n    },\n    directives: [i5.NgIf, i5.NgComponentOutlet],\n    encapsulation: 2\n  });\n  return DynamicLayoutComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ReplaceableRouteContainerComponent = /*#__PURE__*/(() => {\n  class ReplaceableRouteContainerComponent {\n    constructor(route, replaceableComponents, subscription) {\n      this.route = route;\n      this.replaceableComponents = replaceableComponents;\n      this.subscription = subscription;\n    }\n\n    ngOnInit() {\n      this.defaultComponent = this.route.snapshot.data.replaceableComponent.defaultComponent;\n      this.componentKey = this.route.snapshot.data.replaceableComponent.key;\n      const component$ = this.replaceableComponents.get$(this.componentKey).pipe(distinctUntilChanged());\n      this.subscription.addOne(component$, (res = {}) => {\n        this.externalComponent = res.component;\n      });\n    }\n\n  }\n\n  ReplaceableRouteContainerComponent.ɵfac = function ReplaceableRouteContainerComponent_Factory(t) {\n    return new (t || ReplaceableRouteContainerComponent)(i0.ɵɵdirectiveInject(i1$1.ActivatedRoute), i0.ɵɵdirectiveInject(ReplaceableComponentsService), i0.ɵɵdirectiveInject(SubscriptionService));\n  };\n\n  ReplaceableRouteContainerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ReplaceableRouteContainerComponent,\n    selectors: [[\"abp-replaceable-route-container\"]],\n    features: [i0.ɵɵProvidersFeature([SubscriptionService])],\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngComponentOutlet\"]],\n    template: function ReplaceableRouteContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, ReplaceableRouteContainerComponent_ng_container_0_Template, 1, 0, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngComponentOutlet\", ctx.externalComponent || ctx.defaultComponent);\n      }\n    },\n    directives: [i5.NgComponentOutlet],\n    encapsulation: 2\n  });\n  return ReplaceableRouteContainerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RouterOutletComponent = /*#__PURE__*/(() => {\n  class RouterOutletComponent {}\n\n  RouterOutletComponent.ɵfac = function RouterOutletComponent_Factory(t) {\n    return new (t || RouterOutletComponent)();\n  };\n\n  RouterOutletComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: RouterOutletComponent,\n    selectors: [[\"abp-router-outlet\"]],\n    decls: 1,\n    vars: 0,\n    template: function RouterOutletComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"router-outlet\");\n      }\n    },\n    directives: [i1$1.RouterOutlet],\n    encapsulation: 2\n  });\n  return RouterOutletComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // Different locales from .NET\n// Key is .NET locale, value is Angular locale\n\n\nconst differentLocales = {\n  aa: 'en',\n  'aa-DJ': 'en',\n  'aa-ER': 'en',\n  'aa-ET': 'en',\n  'af-ZA': 'af',\n  'agq-CM': 'agq',\n  'ak-GH': 'ak',\n  'am-ET': 'am',\n  'ar-001': 'ar',\n  arn: 'en',\n  'arn-CL': 'en',\n  'as-IN': 'as',\n  'asa-TZ': 'asa',\n  'ast-ES': 'ast',\n  'az-Cyrl-AZ': 'az-Cyrl',\n  'az-Latn-AZ': 'az-Latn',\n  ba: 'ru',\n  'ba-RU': 'ru',\n  'bas-CM': 'bas',\n  'be-BY': 'be',\n  'bem-ZM': 'bem',\n  'bez-TZ': 'bez',\n  'bg-BG': 'bg',\n  bin: 'en',\n  'bin-NG': 'en',\n  'bm-Latn': 'bm',\n  'bm-Latn-ML': 'bm',\n  'bn-BD': 'bn',\n  'bo-CN': 'bo',\n  'br-FR': 'br',\n  'brx-IN': 'brx',\n  'bs-Cyrl-BA': 'bs-Cyrl',\n  'bs-Latn-BA': 'bs-Latn',\n  byn: 'en',\n  'byn-ER': 'en',\n  'ca-ES': 'ca',\n  'ca-ES-valencia': 'ca-ES-VALENCIA',\n  'ce-RU': 'ce',\n  'cgg-UG': 'cgg',\n  'chr-Cher': 'chr',\n  'chr-Cher-US': 'chr',\n  co: 'en',\n  'co-FR': 'fr',\n  'cs-CZ': 'cs',\n  'cu-RU': 'cu',\n  'cy-GB': 'cy',\n  'da-DK': 'da',\n  'dav-KE': 'dav',\n  'de-DE': 'de',\n  'dje-NE': 'dje',\n  'dsb-DE': 'dsb',\n  'dua-CM': 'dua',\n  dv: 'en',\n  'dv-MV': 'en',\n  'dyo-SN': 'dyo',\n  'dz-BT': 'dz',\n  'ebu-KE': 'ebu',\n  'ee-GH': 'ee',\n  'el-GR': 'el',\n  'en-029': 'en',\n  'en-ID': 'en',\n  'en-US': 'en',\n  'eo-001': 'en',\n  'es-ES': 'es',\n  'et-EE': 'et',\n  'eu-ES': 'eu',\n  'ewo-CM': 'ewo',\n  'fa-IR': 'fa',\n  'ff-Latn-SN': 'ff-Latn',\n  'ff-NG': 'ff',\n  'fi-FI': 'fi',\n  'fil-PH': 'fil',\n  'fo-FO': 'fo',\n  'fr-029': 'fr',\n  'fr-FR': 'fr',\n  'fur-IT': 'fur',\n  'fy-NL': 'fy',\n  'ga-IE': 'ga',\n  'gd-GB': 'gd',\n  'gl-ES': 'gl',\n  gn: 'en',\n  'gn-PY': 'en',\n  'gsw-CH': 'gsw',\n  'gu-IN': 'gu',\n  'guz-KE': 'guz',\n  'gv-IM': 'gv',\n  'ha-Latn': 'ha',\n  'ha-Latn-GH': 'ha-GH',\n  'ha-Latn-NE': 'ha-NE',\n  'ha-Latn-NG': 'ha',\n  'haw-US': 'haw',\n  'he-IL': 'he',\n  'hi-IN': 'hi',\n  'hr-HR': 'hr',\n  'hsb-DE': 'hsb',\n  'hu-HU': 'hu',\n  'hy-AM': 'hy',\n  'ia-001': 'ia',\n  'ia-FR': 'ia',\n  ibb: 'en',\n  'ibb-NG': 'en',\n  'id-ID': 'id',\n  'ig-NG': 'ig',\n  'ii-CN': 'ii',\n  'is-IS': 'is',\n  'it-IT': 'it',\n  iu: 'en',\n  'iu-Cans': 'en',\n  'iu-Cans-CA': 'en',\n  'iu-Latn': 'en',\n  'iu-Latn-CA': 'en',\n  'ja-JP': 'ja',\n  'jgo-CM': 'jgo',\n  'jmc-TZ': 'jmc',\n  'jv-Java': 'jv',\n  'jv-Java-ID': 'jv',\n  'jv-Latn': 'jv',\n  'jv-Latn-ID': 'jv',\n  'ka-GE': 'ka',\n  'kab-DZ': 'kab',\n  'kam-KE': 'kam',\n  'kde-TZ': 'kde',\n  'kea-CV': 'kea',\n  'khq-ML': 'khq',\n  'ki-KE': 'ki',\n  'kk-KZ': 'kk',\n  'kkj-CM': 'kkj',\n  'kl-GL': 'kl',\n  'kln-KE': 'kln',\n  'km-KH': 'km',\n  'kn-IN': 'kn',\n  'ko-KR': 'ko',\n  'kok-IN': 'kok',\n  kr: 'en',\n  'kr-NG': 'en',\n  'ks-Arab': 'ks',\n  'ks-Arab-IN': 'ks',\n  'ks-Deva': 'ks',\n  'ks-Deva-IN': 'ks',\n  'ksb-TZ': 'ksb',\n  'ksf-CM': 'ksf',\n  'ksh-DE': 'ksh',\n  'ku-Arab': 'ku',\n  'ku-Arab-IQ': 'ku',\n  'ku-Arab-IR': 'ku',\n  'kw-GB': 'kw',\n  'ky-KG': 'ky',\n  la: 'en',\n  'la-001': 'en',\n  'lag-TZ': 'lag',\n  'lb-LU': 'lb',\n  'lg-UG': 'lg',\n  'lkt-US': 'lkt',\n  'ln-CD': 'ln',\n  'lo-LA': 'lo',\n  'lrc-IR': 'lrc',\n  'lt-LT': 'lt',\n  'lu-CD': 'lu',\n  'luo-KE': 'luo',\n  'luy-KE': 'luy',\n  'lv-LV': 'lv',\n  'mas-KE': 'mas',\n  'mer-KE': 'mer',\n  'mfe-MU': 'mfe',\n  'mg-MG': 'mg',\n  'mgh-MZ': 'mgh',\n  'mgo-CM': 'mgo',\n  'mi-NZ': 'mi',\n  'mk-MK': 'mk',\n  'ml-IN': 'ml',\n  'mn-Cyrl': 'mn',\n  'mn-MN': 'mn',\n  'mn-Mong': 'mn',\n  'mn-Mong-CN': 'mn',\n  'mn-Mong-MN': 'mn',\n  mni: 'en',\n  'mni-IN': 'en',\n  moh: 'en',\n  'moh-CA': 'en',\n  'mr-IN': 'mr',\n  'ms-MY': 'ms',\n  'mt-MT': 'mt',\n  'mua-CM': 'mua',\n  'my-MM': 'my',\n  'mzn-IR': 'mzn',\n  'naq-NA': 'naq',\n  'nb-NO': 'nb',\n  'nd-ZW': 'nd',\n  'ne-NP': 'ne',\n  'nl-NL': 'nl',\n  'nmg-CM': 'ngm',\n  'nn-NO': 'nn',\n  'nnh-CM': 'nnh',\n  no: 'en',\n  nqo: 'en',\n  'nqo-GN': 'en',\n  nr: 'en',\n  'nr-ZA': 'en',\n  nso: 'en',\n  'nso-ZA': 'en',\n  'nus-SS': 'nus',\n  'nyn-UG': 'nyn',\n  oc: 'en',\n  'oc-FR': 'fr',\n  'om-ET': 'om',\n  'or-IN': 'or',\n  'os-GE': 'os',\n  'pa-Arab-PK': 'pa-Arab',\n  'pa-IN': 'pa',\n  pap: 'en',\n  'pap-029': 'en',\n  'pl-PL': 'pl',\n  'prg-001': 'prg',\n  prs: 'en',\n  'prs-AF': 'en',\n  'ps-AF': 'ps',\n  'pt-BR': 'pt',\n  quc: 'en',\n  'quc-Latn': 'en',\n  'quc-Latn-GT': 'en',\n  quz: 'en',\n  'quz-BO': 'en',\n  'quz-EC': 'en',\n  'quz-PE': 'en',\n  'rm-CH': 'rm',\n  'rn-BI': 'rn',\n  'ro-RO': 'ro',\n  'rof-TZ': 'rof',\n  'ru-RU': 'ru',\n  'rw-RW': 'rw',\n  'rwk-TZ': 'rwk',\n  sa: 'en',\n  'sa-IN': 'en',\n  'sah-RU': 'sah',\n  'saq-KE': 'saq',\n  'sbp-TZ': 'en',\n  'sd-Arab': 'sd',\n  'sd-Arab-PK': 'sd',\n  'sd-Deva': 'sd',\n  'sd-Deva-IN': 'sd',\n  'se-NO': 'se',\n  'seh-MZ': 'seh',\n  'ses-ML': 'ses',\n  'sg-CF': 'sg',\n  'shi-Latn-MA': 'shi-Latn',\n  'shi-Tfng-MA': 'shi-Tfng',\n  'si-LK': 'si',\n  'sk-SK': 'sk',\n  'sl-SI': 'sl',\n  sma: 'en',\n  'sma-NO': 'en',\n  'sma-SE': 'en',\n  smj: 'en',\n  'smj-NO': 'en',\n  'smj-SE': 'en',\n  'smn-FI': 'en',\n  sms: 'en',\n  'sms-FI': 'en',\n  'sn-Latn': 'sn',\n  'sn-Latn-ZW': 'sn',\n  'so-SO': 'so',\n  'sq-AL': 'so',\n  'sr-Cyrl-RS': 'sr-Cryl',\n  'sr-Latn-RS': 'sr-Latn',\n  ss: 'en',\n  'ss-SZ': 'en',\n  'ss-ZA': 'en',\n  ssy: 'en',\n  'ssy-ER': 'en',\n  st: 'en',\n  'st-LS': 'en',\n  'st-ZA': 'en',\n  'sv-SE': 'sv',\n  'sw-TZ': 'sw',\n  syr: 'en',\n  'syr-SY': 'en',\n  'ta-IN': 'ta',\n  'te-IN': 'te',\n  'teo-UG': 'teo',\n  'tg-Cyrl': 'tg',\n  'tg-Cyrl-TJ': 'tg',\n  'th-TH': 'th',\n  'ti-ET': 'ti',\n  tig: 'en',\n  'tig-ER': 'en',\n  'tk-TM': 'tk',\n  tn: 'en',\n  'tn-BW': 'en',\n  'tn-ZA': 'en',\n  'to-TO': 'to',\n  'tr-TR': 'tr',\n  ts: 'en',\n  'ts-ZA': 'en',\n  'tt-RU': 'tt',\n  'twq-NE': 'twq',\n  'tzm-Arab': 'tzm',\n  'tzm-Arab-MA': 'tzm',\n  'tzm-Latn': 'tzm',\n  'tzm-Latn-DZ': 'tzm',\n  'tzm-Latn-MA': 'tzm',\n  'tzm-Tfng': 'tzm',\n  'tzm-Tfng-MA': 'tzm',\n  'ug-CN': 'ug',\n  'uk-UA': 'uk',\n  'ur-PK': 'ur',\n  'uz-Arab-AF': 'uz-Arab',\n  'uz-Cyrl-UZ': 'uz-Cyrl',\n  'uz-Latn-UZ': 'uz-Latn',\n  'vai-Latn-LR': 'vai-Latn',\n  'vai-Vaii-LR': 'vai-Vaii',\n  ve: 'en',\n  've-ZA': 'en',\n  'vi-VN': 'vi',\n  'vo-001': 'vo',\n  'vun-TZ': 'vun',\n  'wae-CH': 'wae',\n  wal: 'en',\n  'wal-ET': 'en',\n  'wo-SN': 'wo',\n  'xh-ZA': 'xh',\n  'xog-UG': 'xog',\n  'yav-CM': 'yav',\n  'yi-001': 'yi',\n  'yo-NG': 'yo',\n  'zgh-Tfng': 'zgh',\n  'zgh-Tfng-MA': 'zgh',\n  'zh-CN': 'zh',\n  'zh-HK': 'zh',\n  'zh-MO': 'zh',\n  'zh-SG': 'zh',\n  'zh-TW': 'zh',\n  'zu-ZA': 'zu'\n};\nlet AutofocusDirective = /*#__PURE__*/(() => {\n  class AutofocusDirective {\n    constructor(elRef) {\n      this.elRef = elRef;\n      this._delay = 0;\n    }\n\n    set delay(val) {\n      this._delay = Number(val) || 0;\n    }\n\n    get delay() {\n      return this._delay;\n    }\n\n    ngAfterViewInit() {\n      setTimeout(() => this.elRef.nativeElement.focus(), this.delay);\n    }\n\n  }\n\n  AutofocusDirective.ɵfac = function AutofocusDirective_Factory(t) {\n    return new (t || AutofocusDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  AutofocusDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AutofocusDirective,\n    selectors: [[\"\", \"autofocus\", \"\"]],\n    inputs: {\n      delay: [\"autofocus\", \"delay\"]\n    }\n  });\n  return AutofocusDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet InputEventDebounceDirective = /*#__PURE__*/(() => {\n  class InputEventDebounceDirective {\n    constructor(el, subscription) {\n      this.el = el;\n      this.subscription = subscription;\n      this.debounce = 300;\n      this.debounceEvent = new EventEmitter();\n    }\n\n    ngOnInit() {\n      const input$ = fromEvent(this.el.nativeElement, 'input').pipe(debounceTime(this.debounce));\n      this.subscription.addOne(input$, event => {\n        this.debounceEvent.emit(event);\n      });\n    }\n\n  }\n\n  InputEventDebounceDirective.ɵfac = function InputEventDebounceDirective_Factory(t) {\n    return new (t || InputEventDebounceDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SubscriptionService));\n  };\n\n  InputEventDebounceDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: InputEventDebounceDirective,\n    selectors: [[\"\", \"input.debounce\", \"\"]],\n    inputs: {\n      debounce: \"debounce\"\n    },\n    outputs: {\n      debounceEvent: \"input.debounce\"\n    },\n    features: [i0.ɵɵProvidersFeature([SubscriptionService])]\n  });\n  return InputEventDebounceDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass AbpForContext {\n  constructor($implicit, index, count, list) {\n    this.$implicit = $implicit;\n    this.index = index;\n    this.count = count;\n    this.list = list;\n  }\n\n}\n\nclass RecordView {\n  constructor(record, view) {\n    this.record = record;\n    this.view = view;\n  }\n\n}\n\nlet ForDirective = /*#__PURE__*/(() => {\n  class ForDirective {\n    constructor(tempRef, vcRef, differs) {\n      this.tempRef = tempRef;\n      this.vcRef = vcRef;\n      this.differs = differs;\n    }\n\n    get compareFn() {\n      return this.compareBy || compare;\n    }\n\n    get trackByFn() {\n      return this.trackBy || ((index, item) => item.id || index);\n    }\n\n    iterateOverAppliedOperations(changes) {\n      const rw = [];\n      changes.forEachOperation((record, previousIndex, currentIndex) => {\n        if (record.previousIndex == null) {\n          const view = this.vcRef.createEmbeddedView(this.tempRef, new AbpForContext(null, -1, -1, this.items), currentIndex);\n          rw.push(new RecordView(record, view));\n        } else if (currentIndex == null) {\n          this.vcRef.remove(previousIndex);\n        } else {\n          const view = this.vcRef.get(previousIndex);\n          this.vcRef.move(view, currentIndex);\n          rw.push(new RecordView(record, view));\n        }\n      });\n\n      for (let i = 0, l = rw.length; i < l; i++) {\n        rw[i].view.context.$implicit = rw[i].record.item;\n      }\n    }\n\n    iterateOverAttachedViews(changes) {\n      for (let i = 0, l = this.vcRef.length; i < l; i++) {\n        const viewRef = this.vcRef.get(i);\n        viewRef.context.index = i;\n        viewRef.context.count = l;\n        viewRef.context.list = this.items;\n      }\n\n      changes.forEachIdentityChange(record => {\n        const viewRef = this.vcRef.get(record.currentIndex);\n        viewRef.context.$implicit = record.item;\n      });\n    }\n\n    projectItems(items) {\n      if (!items.length && this.emptyRef) {\n        this.vcRef.clear();\n        this.vcRef.createEmbeddedView(this.emptyRef).rootNodes;\n        this.isShowEmptyRef = true;\n        this.differ = null;\n        return;\n      }\n\n      if (this.emptyRef && this.isShowEmptyRef) {\n        this.vcRef.clear();\n        this.isShowEmptyRef = false;\n      }\n\n      if (!this.differ && items) {\n        this.differ = this.differs.find(items).create(this.trackByFn);\n      }\n\n      if (this.differ) {\n        const changes = this.differ.diff(items);\n\n        if (changes) {\n          this.iterateOverAppliedOperations(changes);\n          this.iterateOverAttachedViews(changes);\n        }\n      }\n    }\n\n    sortItems(items) {\n      if (this.orderBy) {\n        items.sort((a, b) => a[this.orderBy] > b[this.orderBy] ? 1 : a[this.orderBy] < b[this.orderBy] ? -1 : 0);\n      } else {\n        items.sort();\n      }\n    }\n\n    ngOnChanges() {\n      let items = clone(this.items);\n      if (!Array.isArray(items)) return;\n      const compareFn = this.compareFn;\n\n      if (typeof this.filterBy !== 'undefined' && typeof this.filterVal !== 'undefined' && this.filterVal !== '') {\n        items = items.filter(item => compareFn(item[this.filterBy], this.filterVal));\n      }\n\n      switch (this.orderDir) {\n        case 'ASC':\n          this.sortItems(items);\n          this.projectItems(items);\n          break;\n\n        case 'DESC':\n          this.sortItems(items);\n          items.reverse();\n          this.projectItems(items);\n          break;\n\n        default:\n          this.projectItems(items);\n      }\n    }\n\n  }\n\n  ForDirective.ɵfac = function ForDirective_Factory(t) {\n    return new (t || ForDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.IterableDiffers));\n  };\n\n  ForDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ForDirective,\n    selectors: [[\"\", \"abpFor\", \"\"]],\n    inputs: {\n      items: [\"abpForOf\", \"items\"],\n      orderBy: [\"abpForOrderBy\", \"orderBy\"],\n      orderDir: [\"abpForOrderDir\", \"orderDir\"],\n      filterBy: [\"abpForFilterBy\", \"filterBy\"],\n      filterVal: [\"abpForFilterVal\", \"filterVal\"],\n      trackBy: [\"abpForTrackBy\", \"trackBy\"],\n      compareBy: [\"abpForCompareBy\", \"compareBy\"],\n      emptyRef: [\"abpForEmptyRef\", \"emptyRef\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return ForDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet FormSubmitDirective = /*#__PURE__*/(() => {\n  class FormSubmitDirective {\n    constructor(formGroupDirective, host, cdRef, subscription) {\n      this.formGroupDirective = formGroupDirective;\n      this.host = host;\n      this.cdRef = cdRef;\n      this.subscription = subscription;\n      this.debounce = 200;\n      this.markAsDirtyWhenSubmit = true;\n      this.ngSubmit = new EventEmitter();\n      this.executedNgSubmit = false;\n    }\n\n    ngOnInit() {\n      this.subscription.addOne(this.formGroupDirective.ngSubmit, () => {\n        if (this.markAsDirtyWhenSubmit) {\n          this.markAsDirty();\n        }\n\n        this.executedNgSubmit = true;\n      });\n      const keyup$ = fromEvent(this.host.nativeElement, 'keyup').pipe(debounceTime(this.debounce), filter(event => !(event.target instanceof HTMLTextAreaElement)), filter(event => event && event.key === 'Enter'));\n      this.subscription.addOne(keyup$, () => {\n        if (!this.executedNgSubmit) {\n          this.host.nativeElement.dispatchEvent(new Event('submit', {\n            bubbles: true,\n            cancelable: true\n          }));\n        }\n\n        this.executedNgSubmit = false;\n      });\n    }\n\n    markAsDirty() {\n      const {\n        form\n      } = this.formGroupDirective;\n      setDirty(form.controls);\n      form.markAsDirty();\n      this.cdRef.detectChanges();\n    }\n\n  }\n\n  FormSubmitDirective.ɵfac = function FormSubmitDirective_Factory(t) {\n    return new (t || FormSubmitDirective)(i0.ɵɵdirectiveInject(i1$2.FormGroupDirective, 2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(SubscriptionService));\n  };\n\n  FormSubmitDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FormSubmitDirective,\n    selectors: [[\"form\", \"ngSubmit\", \"\", \"formGroup\", \"\"]],\n    inputs: {\n      debounce: \"debounce\",\n      notValidateOnSubmit: \"notValidateOnSubmit\",\n      markAsDirtyWhenSubmit: \"markAsDirtyWhenSubmit\"\n    },\n    outputs: {\n      ngSubmit: \"ngSubmit\"\n    },\n    features: [i0.ɵɵProvidersFeature([SubscriptionService])]\n  });\n  return FormSubmitDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction setDirty(controls) {\n  if (Array.isArray(controls)) {\n    controls.forEach(group => {\n      setDirty(group.controls);\n    });\n    return;\n  }\n\n  Object.keys(controls).forEach(key => {\n    controls[key].markAsDirty();\n    controls[key].updateValueAndValidity();\n  });\n}\n\nlet InitDirective = /*#__PURE__*/(() => {\n  class InitDirective {\n    constructor(elRef) {\n      this.elRef = elRef;\n      this.init = new EventEmitter();\n    }\n\n    ngAfterViewInit() {\n      this.init.emit(this.elRef);\n    }\n\n  }\n\n  InitDirective.ɵfac = function InitDirective_Factory(t) {\n    return new (t || InitDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  InitDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: InitDirective,\n    selectors: [[\"\", \"abpInit\", \"\"]],\n    outputs: {\n      init: \"abpInit\"\n    }\n  });\n  return InitDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet PermissionDirective = /*#__PURE__*/(() => {\n  class PermissionDirective {\n    constructor(templateRef, vcRef, permissionService, cdRef) {\n      this.templateRef = templateRef;\n      this.vcRef = vcRef;\n      this.permissionService = permissionService;\n      this.cdRef = cdRef;\n      this.runChangeDetection = true;\n      this.cdrSubject = new ReplaySubject();\n      this.rendered = false;\n    }\n\n    check() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n\n      this.subscription = this.permissionService.getGrantedPolicy$(this.condition || '').pipe(distinctUntilChanged()).subscribe(isGranted => {\n        this.vcRef.clear();\n        if (isGranted) this.vcRef.createEmbeddedView(this.templateRef);\n\n        if (this.runChangeDetection) {\n          if (!this.rendered) {\n            this.cdrSubject.next();\n          } else {\n            this.cdRef.detectChanges();\n          }\n        } else {\n          this.cdRef.markForCheck();\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.subscription) this.subscription.unsubscribe();\n    }\n\n    ngOnChanges() {\n      this.check();\n    }\n\n    ngAfterViewInit() {\n      this.cdrSubject.pipe(take(1)).subscribe(() => this.cdRef.detectChanges());\n      this.rendered = true;\n    }\n\n  }\n\n  PermissionDirective.ɵfac = function PermissionDirective_Factory(t) {\n    return new (t || PermissionDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 8), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(PermissionService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  PermissionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: PermissionDirective,\n    selectors: [[\"\", \"abpPermission\", \"\"]],\n    inputs: {\n      condition: [\"abpPermission\", \"condition\"],\n      runChangeDetection: [\"abpPermissionRunChangeDetection\", \"runChangeDetection\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return PermissionDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ReplaceableTemplateDirective = /*#__PURE__*/(() => {\n  class ReplaceableTemplateDirective {\n    constructor(injector, templateRef, cfRes, vcRef, replaceableComponents, subscription) {\n      this.injector = injector;\n      this.templateRef = templateRef;\n      this.cfRes = cfRes;\n      this.vcRef = vcRef;\n      this.replaceableComponents = replaceableComponents;\n      this.subscription = subscription;\n      this.providedData = {\n        inputs: {},\n        outputs: {}\n      };\n      this.context = {};\n      this.defaultComponentSubscriptions = {};\n      this.initialized = false;\n      this.context = {\n        initTemplate: ref => {\n          this.resetDefaultComponent();\n          this.defaultComponentRef = ref;\n          this.setDefaultComponentInputs();\n        }\n      };\n    }\n\n    ngOnInit() {\n      const component$ = this.replaceableComponents.get$(this.data.componentKey).pipe(filter((res = {}) => !this.initialized || !compare(res.component, this.externalComponent)));\n      this.subscription.addOne(component$, (res = {}) => {\n        this.vcRef.clear();\n        this.externalComponent = res.component;\n\n        if (this.defaultComponentRef) {\n          this.resetDefaultComponent();\n        }\n\n        if (res.component) {\n          this.setProvidedData();\n          const customInjector = Injector.create({\n            providers: [{\n              provide: 'REPLACEABLE_DATA',\n              useValue: this.providedData\n            }],\n            parent: this.injector\n          });\n          this.vcRef.createComponent(this.cfRes.resolveComponentFactory(res.component), 0, customInjector);\n        } else {\n          this.vcRef.createEmbeddedView(this.templateRef, this.context);\n        }\n\n        this.initialized = true;\n      });\n    }\n\n    ngOnChanges(changes) {\n      var _a, _b;\n\n      if (((_b = (_a = changes === null || changes === void 0 ? void 0 : changes.data) === null || _a === void 0 ? void 0 : _a.currentValue) === null || _b === void 0 ? void 0 : _b.inputs) && this.defaultComponentRef) {\n        this.setDefaultComponentInputs();\n      }\n    }\n\n    setDefaultComponentInputs() {\n      if (!this.defaultComponentRef || !this.data.inputs && !this.data.outputs) return;\n\n      if (this.data.inputs) {\n        for (const key in this.data.inputs) {\n          if (Object.prototype.hasOwnProperty.call(this.data.inputs, key)) {\n            if (!compare(this.defaultComponentRef[key], this.data.inputs[key].value)) {\n              this.defaultComponentRef[key] = this.data.inputs[key].value;\n            }\n          }\n        }\n      }\n\n      if (this.data.outputs) {\n        for (const key in this.data.outputs) {\n          if (Object.prototype.hasOwnProperty.call(this.data.outputs, key)) {\n            if (!this.defaultComponentSubscriptions[key]) {\n              this.defaultComponentSubscriptions[key] = this.defaultComponentRef[key].subscribe(value => {\n                var _a;\n\n                (_a = this.data.outputs) === null || _a === void 0 ? void 0 : _a[key](value);\n              });\n            }\n          }\n        }\n      }\n    }\n\n    setProvidedData() {\n      this.providedData = Object.assign(Object.assign({\n        outputs: {}\n      }, this.data), {\n        inputs: {}\n      });\n      if (!this.data.inputs) return;\n      Object.defineProperties(this.providedData.inputs, Object.assign({}, Object.keys(this.data.inputs).reduce((acc, key) => {\n        var _a;\n\n        return Object.assign(Object.assign({}, acc), {\n          [key]: Object.assign({\n            enumerable: true,\n            configurable: true,\n            get: () => {\n              var _a;\n\n              return (_a = this.data.inputs[key]) === null || _a === void 0 ? void 0 : _a.value;\n            }\n          }, ((_a = this.data.inputs[key]) === null || _a === void 0 ? void 0 : _a.twoWay) && {\n            set: newValue => {\n              this.data.inputs[key].value = newValue;\n              this.data.outputs[`${key}Change`](newValue);\n            }\n          })\n        });\n      }, {})));\n    }\n\n    resetDefaultComponent() {\n      Object.keys(this.defaultComponentSubscriptions).forEach(key => {\n        this.defaultComponentSubscriptions[key].unsubscribe();\n      });\n      this.defaultComponentSubscriptions = {};\n      this.defaultComponentRef = null;\n    }\n\n  }\n\n  ReplaceableTemplateDirective.ɵfac = function ReplaceableTemplateDirective_Factory(t) {\n    return new (t || ReplaceableTemplateDirective)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(ReplaceableComponentsService), i0.ɵɵdirectiveInject(SubscriptionService));\n  };\n\n  ReplaceableTemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ReplaceableTemplateDirective,\n    selectors: [[\"\", \"abpReplaceableTemplate\", \"\"]],\n    inputs: {\n      data: [\"abpReplaceableTemplate\", \"data\"]\n    },\n    features: [i0.ɵɵProvidersFeature([SubscriptionService]), i0.ɵɵNgOnChangesFeature]\n  });\n  return ReplaceableTemplateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet StopPropagationDirective = /*#__PURE__*/(() => {\n  class StopPropagationDirective {\n    constructor(el, subscription) {\n      this.el = el;\n      this.subscription = subscription;\n      this.stopPropEvent = new EventEmitter();\n    }\n\n    ngOnInit() {\n      this.subscription.addOne(fromEvent(this.el.nativeElement, 'click'), event => {\n        event.stopPropagation();\n        this.stopPropEvent.emit(event);\n      });\n    }\n\n  }\n\n  StopPropagationDirective.ɵfac = function StopPropagationDirective_Factory(t) {\n    return new (t || StopPropagationDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SubscriptionService));\n  };\n\n  StopPropagationDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: StopPropagationDirective,\n    selectors: [[\"\", \"click.stop\", \"\"]],\n    outputs: {\n      stopPropEvent: \"click.stop\"\n    },\n    features: [i0.ɵɵProvidersFeature([SubscriptionService])]\n  });\n  return StopPropagationDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet OAuthConfigurationHandler = /*#__PURE__*/(() => {\n  class OAuthConfigurationHandler {\n    constructor(oAuthService, environmentService, options) {\n      this.oAuthService = oAuthService;\n      this.environmentService = environmentService;\n      this.options = options;\n      this.listenToSetEnvironment();\n    }\n\n    listenToSetEnvironment() {\n      this.environmentService.createOnUpdateStream(state => state).pipe(map(environment => environment.oAuthConfig), filter(config => !compare(config, this.options.environment.oAuthConfig))).subscribe(config => {\n        this.oAuthService.configure(config);\n      });\n    }\n\n  }\n\n  OAuthConfigurationHandler.ɵfac = function OAuthConfigurationHandler_Factory(t) {\n    return new (t || OAuthConfigurationHandler)(i0.ɵɵinject(i1$3.OAuthService), i0.ɵɵinject(EnvironmentService), i0.ɵɵinject(CORE_OPTIONS));\n  };\n\n  OAuthConfigurationHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OAuthConfigurationHandler,\n    factory: OAuthConfigurationHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return OAuthConfigurationHandler;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RoutesHandler = /*#__PURE__*/(() => {\n  class RoutesHandler {\n    constructor(routes, router) {\n      this.routes = routes;\n      this.router = router;\n      this.addRoutes();\n    }\n\n    addRoutes() {\n      var _a, _b;\n\n      (_b = (_a = this.router) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.forEach(({\n        path = '',\n        data\n      }) => {\n        if (!(data === null || data === void 0 ? void 0 : data.routes)) return;\n\n        if (Array.isArray(data.routes)) {\n          this.routes.add(data.routes);\n          return;\n        }\n\n        const routes = flatRoutes([Object.assign({\n          path\n        }, data.routes)], {\n          path: ''\n        });\n        this.routes.add(routes);\n      });\n    }\n\n  }\n\n  RoutesHandler.ɵfac = function RoutesHandler_Factory(t) {\n    return new (t || RoutesHandler)(i0.ɵɵinject(RoutesService), i0.ɵɵinject(i1$1.Router, 8));\n  };\n\n  RoutesHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RoutesHandler,\n    factory: RoutesHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return RoutesHandler;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction flatRoutes(routes, parent) {\n  if (!routes) return [];\n  return routes.reduce((acc, route) => {\n    const _a = Object.assign(Object.assign({}, route), {\n      parentName: parent.name,\n      path: (parent.path + '/' + route.path).replace(/\\/\\//g, '/')\n    }),\n          {\n      children\n    } = _a,\n          current = __rest(_a, [\"children\"]);\n\n    acc.push(current, ...flatRoutes(children, current));\n    return acc;\n  }, []);\n}\n\nconst TENANT_KEY = new InjectionToken('TENANT_KEY');\n\nfunction getPathName(url) {\n  const {\n    pathname\n  } = new URL(url, window.location.origin);\n  return pathname;\n}\n\nclass WebHttpUrlEncodingCodec {\n  encodeKey(k) {\n    return encodeURIComponent(k);\n  }\n\n  encodeValue(v) {\n    return encodeURIComponent(v);\n  }\n\n  decodeKey(k) {\n    return decodeURIComponent(k);\n  }\n\n  decodeValue(v) {\n    return decodeURIComponent(v);\n  }\n\n}\n\nconst LOADER_DELAY = new InjectionToken('LOADER_DELAY');\nlet HttpWaitService = /*#__PURE__*/(() => {\n  class HttpWaitService {\n    constructor(injector) {\n      this.store = new InternalStore({\n        requests: [],\n        filteredRequests: []\n      });\n      this.destroy$ = new Subject();\n      this.delay = injector.get(LOADER_DELAY, 500);\n    }\n\n    getLoading() {\n      return !!this.applyFilter(this.store.state.requests).length;\n    }\n\n    getLoading$() {\n      return this.store.sliceState(({\n        requests\n      }) => requests).pipe(map(requests => !!this.applyFilter(requests).length), switchMap(condition => condition ? this.delay === 0 ? of(true) : timer(this.delay).pipe(mapTo(true), takeUntil(this.destroy$)) : of(false)), tap(() => this.destroy$.next()));\n    }\n\n    updateLoading$() {\n      return this.store.sliceUpdate(({\n        requests\n      }) => !!this.applyFilter(requests).length);\n    }\n\n    clearLoading() {\n      this.store.patch({\n        requests: []\n      });\n    }\n\n    addRequest(request) {\n      this.store.patch({\n        requests: [...this.store.state.requests, request]\n      });\n    }\n\n    deleteRequest(request) {\n      const requests = this.store.state.requests.filter(r => r !== request);\n      this.store.patch({\n        requests\n      });\n    }\n\n    addFilter(request) {\n      const requests = Array.isArray(request) ? request : [request];\n      const filteredRequests = [...this.store.state.filteredRequests.filter(f => !requests.some(r => this.isSameRequest(f, r))), ...requests];\n      this.store.patch({\n        filteredRequests\n      });\n    }\n\n    removeFilter(request) {\n      const requests = Array.isArray(request) ? request : [request];\n      const filteredRequests = this.store.state.filteredRequests.filter(f => !requests.some(r => this.isSameRequest(f, r)));\n      this.store.patch({\n        filteredRequests\n      });\n    }\n\n    applyFilter(requests) {\n      const {\n        filteredRequests\n      } = this.store.state;\n      return requests.filter(({\n        method,\n        url\n      }) => !filteredRequests.find(filteredRequest => this.isSameRequest(filteredRequest, {\n        method,\n        endpoint: getPathName(url)\n      })));\n    }\n\n    isSameRequest(filteredRequest, request) {\n      const {\n        method,\n        endpoint\n      } = filteredRequest;\n      return endpoint === request.endpoint && method === request.method;\n    }\n\n  }\n\n  HttpWaitService.ɵfac = function HttpWaitService_Factory(t) {\n    return new (t || HttpWaitService)(i0.ɵɵinject(i0.Injector));\n  };\n\n  HttpWaitService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: HttpWaitService,\n    factory: HttpWaitService.ɵfac,\n    providedIn: 'root'\n  });\n  return HttpWaitService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ApiInterceptor = /*#__PURE__*/(() => {\n  class ApiInterceptor {\n    constructor(oAuthService, sessionState, httpWaitService, tenantKey) {\n      this.oAuthService = oAuthService;\n      this.sessionState = sessionState;\n      this.httpWaitService = httpWaitService;\n      this.tenantKey = tenantKey;\n    }\n\n    intercept(request, next) {\n      this.httpWaitService.addRequest(request);\n      return next.handle(request.clone({\n        setHeaders: this.getAdditionalHeaders(request.headers)\n      })).pipe(finalize(() => this.httpWaitService.deleteRequest(request)));\n    }\n\n    getAdditionalHeaders(existingHeaders) {\n      const headers = {};\n      const token = this.oAuthService.getAccessToken();\n\n      if (!(existingHeaders === null || existingHeaders === void 0 ? void 0 : existingHeaders.has('Authorization')) && token) {\n        headers['Authorization'] = `Bearer ${token}`;\n      }\n\n      const lang = this.sessionState.getLanguage();\n\n      if (!(existingHeaders === null || existingHeaders === void 0 ? void 0 : existingHeaders.has('Accept-Language')) && lang) {\n        headers['Accept-Language'] = lang;\n      }\n\n      const tenant = this.sessionState.getTenant();\n\n      if (!(existingHeaders === null || existingHeaders === void 0 ? void 0 : existingHeaders.has(this.tenantKey)) && (tenant === null || tenant === void 0 ? void 0 : tenant.id)) {\n        headers[this.tenantKey] = tenant.id;\n      }\n\n      headers['X-Requested-With'] = 'XMLHttpRequest';\n      return headers;\n    }\n\n  }\n\n  ApiInterceptor.ɵfac = function ApiInterceptor_Factory(t) {\n    return new (t || ApiInterceptor)(i0.ɵɵinject(i1$3.OAuthService), i0.ɵɵinject(SessionStateService), i0.ɵɵinject(HttpWaitService), i0.ɵɵinject(TENANT_KEY));\n  };\n\n  ApiInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ApiInterceptor,\n    factory: ApiInterceptor.ɵfac,\n    providedIn: 'root'\n  });\n  return ApiInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LocalizationPipe = /*#__PURE__*/(() => {\n  class LocalizationPipe {\n    constructor(localization) {\n      this.localization = localization;\n    }\n\n    transform(value = '', ...interpolateParams) {\n      const params = interpolateParams.reduce((acc, val) => {\n        if (!acc) {\n          return val;\n        }\n\n        if (!val) {\n          return acc;\n        }\n\n        return Array.isArray(val) ? [...acc, ...val] : [...acc, val];\n      }, []) || [];\n      return this.localization.instant(value, ...params);\n    }\n\n  }\n\n  LocalizationPipe.ɵfac = function LocalizationPipe_Factory(t) {\n    return new (t || LocalizationPipe)(i0.ɵɵdirectiveInject(LocalizationService, 16));\n  };\n\n  LocalizationPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"abpLocalization\",\n    type: LocalizationPipe,\n    pure: true\n  });\n  LocalizationPipe.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LocalizationPipe,\n    factory: LocalizationPipe.ɵfac\n  });\n  return LocalizationPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LocalizationModule = /*#__PURE__*/(() => {\n  class LocalizationModule {}\n\n  LocalizationModule.ɵfac = function LocalizationModule_Factory(t) {\n    return new (t || LocalizationModule)();\n  };\n\n  LocalizationModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LocalizationModule\n  });\n  LocalizationModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return LocalizationModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet SortPipe = /*#__PURE__*/(() => {\n  class SortPipe {\n    transform(value, sortOrder = 'asc', sortKey) {\n      sortOrder = sortOrder && sortOrder.toLowerCase();\n      if (!value || sortOrder !== 'asc' && sortOrder !== 'desc') return value;\n      let numberArray = [];\n      let stringArray = [];\n\n      if (!sortKey) {\n        numberArray = value.filter(item => typeof item === 'number').sort();\n        stringArray = value.filter(item => typeof item === 'string').sort();\n      } else {\n        numberArray = value.filter(item => typeof item[sortKey] === 'number').sort((a, b) => a[sortKey] - b[sortKey]);\n        stringArray = value.filter(item => typeof item[sortKey] === 'string').sort((a, b) => {\n          if (a[sortKey] < b[sortKey]) return -1;else if (a[sortKey] > b[sortKey]) return 1;else return 0;\n        });\n      }\n\n      const sorted = [...numberArray, ...stringArray, ...value.filter(item => typeof (sortKey ? item[sortKey] : item) !== 'number' && typeof (sortKey ? item[sortKey] : item) !== 'string')];\n      return sortOrder === 'asc' ? sorted : sorted.reverse();\n    }\n\n  }\n\n  SortPipe.ɵfac = function SortPipe_Factory(t) {\n    return new (t || SortPipe)();\n  };\n\n  SortPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"abpSort\",\n    type: SortPipe,\n    pure: true\n  });\n  SortPipe.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SortPipe,\n    factory: SortPipe.ɵfac\n  });\n  return SortPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst INJECTOR_PIPE_DATA_TOKEN = new InjectionToken('INJECTOR_PIPE_DATA_TOKEN');\nlet ToInjectorPipe = /*#__PURE__*/(() => {\n  class ToInjectorPipe {\n    constructor(injector) {\n      this.injector = injector;\n    }\n\n    transform(value, token = INJECTOR_PIPE_DATA_TOKEN, name = 'ToInjectorPipe') {\n      return Injector.create({\n        providers: [{\n          provide: token,\n          useValue: value\n        }],\n        parent: this.injector,\n        name\n      });\n    }\n\n  }\n\n  ToInjectorPipe.ɵfac = function ToInjectorPipe_Factory(t) {\n    return new (t || ToInjectorPipe)(i0.ɵɵdirectiveInject(i0.Injector, 16));\n  };\n\n  ToInjectorPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"toInjector\",\n    type: ToInjectorPipe,\n    pure: true\n  });\n  return ToInjectorPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst COOKIE_LANGUAGE_KEY = new InjectionToken('COOKIE_LANGUAGE_KEY', {\n  factory: () => '.AspNetCore.Culture'\n});\n\nfunction setLanguageToCookie(injector) {\n  return () => {\n    const sessionState = injector.get(SessionStateService);\n    const document = injector.get(DOCUMENT);\n    const cookieLanguageKey = injector.get(COOKIE_LANGUAGE_KEY);\n    sessionState.getLanguage$().subscribe(language => {\n      const cookieValue = encodeURIComponent(`c=${language}|uic=${language}`);\n      document.cookie = `${cookieLanguageKey}=${cookieValue}`;\n    });\n  };\n}\n\nconst CookieLanguageProvider = {\n  provide: APP_INITIALIZER,\n  useFactory: setLanguageToCookie,\n  deps: [Injector],\n  multi: true\n};\n\nclass LocaleId extends String {\n  constructor(localizationService) {\n    super();\n    this.localizationService = localizationService;\n  }\n\n  toString() {\n    const {\n      currentLang\n    } = this.localizationService;\n    return differentLocales[currentLang] || currentLang;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n}\n\nconst LocaleProvider = {\n  provide: LOCALE_ID,\n  useClass: LocaleId,\n  deps: [LocalizationService]\n};\nconst cookieKey = 'rememberMe';\nconst storageKey = 'passwordFlow';\n\nfunction pipeToLogin(params, injector) {\n  const configState = injector.get(ConfigStateService);\n  const router = injector.get(Router);\n  return pipe(switchMap(() => configState.refreshAppState()), tap(() => {\n    setRememberMe(params.rememberMe);\n    if (params.redirectUrl) router.navigate([params.redirectUrl]);\n  }));\n}\n\nfunction setTokenResponseToStorage(injector, tokenRes) {\n  const {\n    access_token,\n    refresh_token,\n    scope: grantedScopes,\n    expires_in\n  } = tokenRes;\n  const storage = injector.get(OAuthStorage);\n  storage.setItem('access_token', access_token);\n  storage.setItem('refresh_token', refresh_token);\n  storage.setItem('access_token_stored_at', '' + Date.now());\n\n  if (grantedScopes) {\n    storage.setItem('granted_scopes', JSON.stringify(grantedScopes.split(' ')));\n  }\n\n  if (expires_in) {\n    const expiresInMilliSeconds = expires_in * 1000;\n    const now = new Date();\n    const expiresAt = now.getTime() + expiresInMilliSeconds;\n    storage.setItem('expires_at', '' + expiresAt);\n  }\n}\n\nfunction setRememberMe(remember) {\n  removeRememberMe();\n  localStorage.setItem(storageKey, 'true');\n  document.cookie = `${cookieKey}=true; path=/${remember ? ' ;expires=Fri, 31 Dec 9999 23:59:59 GMT' : ''}`;\n}\n\nfunction removeRememberMe() {\n  localStorage.removeItem(storageKey);\n  document.cookie = cookieKey + '= ; path=/; expires = Thu, 01 Jan 1970 00:00:00 GMT';\n}\n\nconst oAuthStorage = localStorage;\n\nclass AuthFlowStrategy {\n  constructor(injector) {\n    this.injector = injector;\n\n    this.catchError = err => {\n      this.httpErrorReporter.reportError(err);\n      return of(null);\n    };\n\n    this.httpErrorReporter = injector.get(HttpErrorReporterService);\n    this.environment = injector.get(EnvironmentService);\n    this.configState = injector.get(ConfigStateService);\n    this.oAuthService = injector.get(OAuthService);\n    this.sessionState = injector.get(SessionStateService);\n    this.oAuthConfig = this.environment.getEnvironment().oAuthConfig;\n    this.tenantKey = injector.get(TENANT_KEY);\n    this.listenToOauthErrors();\n  }\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const shouldClear = shouldStorageClear(this.environment.getEnvironment().oAuthConfig.clientId, oAuthStorage);\n      if (shouldClear) clearOAuthStorage(oAuthStorage);\n      this.oAuthService.configure(this.oAuthConfig);\n      this.oAuthService.events.pipe(filter(event => event.type === 'token_refresh_error')).subscribe(() => this.navigateToLogin());\n      return this.oAuthService.loadDiscoveryDocument().then(() => {\n        if (this.oAuthService.hasValidAccessToken() || !this.oAuthService.getRefreshToken()) {\n          return Promise.resolve();\n        }\n\n        return this.refreshToken();\n      }).catch(this.catchError);\n    });\n  }\n\n  refreshToken() {\n    return this.oAuthService.refreshToken().catch(() => clearOAuthStorage());\n  }\n\n  listenToOauthErrors() {\n    this.oAuthService.events.pipe(filter(event => event instanceof OAuthErrorEvent), tap(() => clearOAuthStorage()), switchMap(() => this.configState.refreshAppState())).subscribe();\n  }\n\n}\n\nclass AuthCodeFlowStrategy extends AuthFlowStrategy {\n  constructor() {\n    super(...arguments);\n    this.isInternalAuth = false;\n  }\n\n  init() {\n    const _super = Object.create(null, {\n      init: {\n        get: () => super.init\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return _super.init.call(this).then(() => this.oAuthService.tryLogin().catch(noop)).then(() => this.oAuthService.setupAutomaticSilentRefresh({}, 'access_token'));\n    });\n  }\n\n  navigateToLogin(queryParams) {\n    this.oAuthService.initCodeFlow('', this.getCultureParams(queryParams));\n  }\n\n  checkIfInternalAuth(queryParams) {\n    this.oAuthService.initCodeFlow('', this.getCultureParams(queryParams));\n    return false;\n  }\n\n  logout(queryParams) {\n    return from(this.oAuthService.revokeTokenAndLogout(this.getCultureParams(queryParams)));\n  }\n\n  login(queryParams) {\n    this.oAuthService.initCodeFlow('', this.getCultureParams(queryParams));\n    return of(null);\n  }\n\n  getCultureParams(queryParams) {\n    const lang = this.sessionState.getLanguage();\n    const culture = {\n      culture: lang,\n      'ui-culture': lang\n    };\n    return Object.assign(Object.assign({}, lang && culture), queryParams);\n  }\n\n}\n\nclass AuthPasswordFlowStrategy extends AuthFlowStrategy {\n  constructor() {\n    super(...arguments);\n    this.isInternalAuth = true;\n    this.cookieKey = 'rememberMe';\n    this.storageKey = 'passwordFlow';\n  }\n\n  listenToTokenExpiration() {\n    this.oAuthService.events.pipe(filter(event => event instanceof OAuthInfoEvent && event.type === 'token_expires' && event.info === 'access_token')).subscribe(() => {\n      if (this.oAuthService.getRefreshToken()) {\n        this.refreshToken();\n      } else {\n        this.oAuthService.logOut();\n        removeRememberMe();\n        this.configState.refreshAppState().subscribe();\n      }\n    });\n  }\n\n  init() {\n    const _super = Object.create(null, {\n      init: {\n        get: () => super.init\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!getCookieValueByName(this.cookieKey) && localStorage.getItem(this.storageKey)) {\n        this.oAuthService.logOut();\n      }\n\n      return _super.init.call(this).then(() => this.listenToTokenExpiration());\n    });\n  }\n\n  navigateToLogin(queryParams) {\n    const router = this.injector.get(Router);\n    router.navigate(['/account/login'], {\n      queryParams\n    });\n  }\n\n  checkIfInternalAuth() {\n    return true;\n  }\n\n  login(params) {\n    const tenant = this.sessionState.getTenant();\n    return from(this.oAuthService.fetchTokenUsingPasswordFlow(params.username, params.password, new HttpHeaders(Object.assign({}, tenant && tenant.id && {\n      [this.tenantKey]: tenant.id\n    })))).pipe(this.pipeToLogin(params));\n  }\n\n  pipeToLogin(params) {\n    const router = this.injector.get(Router);\n    return pipe(switchMap(() => this.configState.refreshAppState()), tap(() => {\n      setRememberMe(params.rememberMe);\n      if (params.redirectUrl) router.navigate([params.redirectUrl]);\n    }));\n  }\n\n  logout(queryParams) {\n    const router = this.injector.get(Router);\n    return from(this.oAuthService.revokeTokenAndLogout(queryParams)).pipe(switchMap(() => this.configState.refreshAppState()), tap(() => {\n      router.navigateByUrl('/');\n      removeRememberMe();\n    }));\n  }\n\n  refreshToken() {\n    return this.oAuthService.refreshToken().catch(() => {\n      clearOAuthStorage();\n      removeRememberMe();\n    });\n  }\n\n}\n\nconst AUTH_FLOW_STRATEGY = {\n  Code(injector) {\n    return new AuthCodeFlowStrategy(injector);\n  },\n\n  Password(injector) {\n    return new AuthPasswordFlowStrategy(injector);\n  }\n\n};\n\nfunction clearOAuthStorage(storage = oAuthStorage) {\n  const keys = ['access_token', 'id_token', 'refresh_token', 'nonce', 'PKCE_verifier', 'expires_at', 'id_token_claims_obj', 'id_token_expires_at', 'id_token_stored_at', 'access_token_stored_at', 'granted_scopes', 'session_state'];\n  keys.forEach(key => storage.removeItem(key));\n}\n\nfunction shouldStorageClear(clientId, storage) {\n  const key = 'abpOAuthClientId';\n\n  if (!storage.getItem(key)) {\n    storage.setItem(key, clientId);\n    return false;\n  }\n\n  const shouldClear = storage.getItem(key) !== clientId;\n  if (shouldClear) storage.setItem(key, clientId);\n  return shouldClear;\n}\n\nfunction getCookieValueByName(name) {\n  const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));\n  return match ? match[2] : '';\n}\n\nDate.prototype.toLocalISOString = function () {\n  const timezoneOffset = this.getTimezoneOffset();\n  return new Date(this.getTime() - timezoneOffset * 60000).toISOString();\n};\n\nlet AuthService = /*#__PURE__*/(() => {\n  class AuthService {\n    constructor(injector) {\n      this.injector = injector;\n    }\n\n    get isInternalAuth() {\n      return this.strategy.isInternalAuth;\n    }\n\n    init() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const environmentService = this.injector.get(EnvironmentService);\n        return environmentService.getEnvironment$().pipe(map(env => env === null || env === void 0 ? void 0 : env.oAuthConfig), filter(oAuthConfig => !!oAuthConfig), tap(oAuthConfig => {\n          this.strategy = oAuthConfig.responseType === 'code' ? AUTH_FLOW_STRATEGY.Code(this.injector) : AUTH_FLOW_STRATEGY.Password(this.injector);\n        }), switchMap(() => from(this.strategy.init())), take(1)).toPromise();\n      });\n    }\n\n    logout(queryParams) {\n      return this.strategy.logout(queryParams);\n    }\n\n    navigateToLogin(queryParams) {\n      this.strategy.navigateToLogin(queryParams);\n    }\n\n    login(params) {\n      return this.strategy.login(params);\n    }\n\n  }\n\n  AuthService.ɵfac = function AuthService_Factory(t) {\n    return new (t || AuthService)(i0.ɵɵinject(i0.Injector));\n  };\n\n  AuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthService,\n    factory: AuthService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst APP_INIT_ERROR_HANDLERS = new InjectionToken('APP_INIT_ERROR_HANDLERS');\n\nfunction getRemoteEnv(injector, environment) {\n  const environmentService = injector.get(EnvironmentService);\n  const {\n    remoteEnv\n  } = environment;\n  const {\n    headers = {},\n    method = 'GET',\n    url\n  } = remoteEnv || {};\n  if (!url) return Promise.resolve();\n  const http = injector.get(HttpClient);\n  const httpErrorReporter = injector.get(HttpErrorReporterService);\n  return http.request(method, url, {\n    headers\n  }).pipe(catchError(err => {\n    httpErrorReporter.reportError(err);\n    return of(null);\n  }), // TODO: Consider get handle function from a provider\n  tap(env => environmentService.setState(mergeEnvironments(environment, env, remoteEnv)))).toPromise();\n}\n\nfunction mergeEnvironments(local, remote, config) {\n  switch (config.mergeStrategy) {\n    case 'deepmerge':\n      return deepMerge(local, remote);\n\n    case 'overwrite':\n    case null:\n    case undefined:\n      return remote;\n\n    default:\n      return config.mergeStrategy(local, remote);\n  }\n}\n\nlet AbpTenantService = /*#__PURE__*/(() => {\n  class AbpTenantService {\n    constructor(restService) {\n      this.restService = restService;\n      this.apiName = 'abp';\n\n      this.findTenantById = id => this.restService.request({\n        method: 'GET',\n        url: `/api/abp/multi-tenancy/tenants/by-id/${id}`\n      }, {\n        apiName: this.apiName\n      });\n\n      this.findTenantByName = name => this.restService.request({\n        method: 'GET',\n        url: `/api/abp/multi-tenancy/tenants/by-name/${name}`\n      }, {\n        apiName: this.apiName\n      });\n    }\n\n  }\n\n  AbpTenantService.ɵfac = function AbpTenantService_Factory(t) {\n    return new (t || AbpTenantService)(i0.ɵɵinject(RestService));\n  };\n\n  AbpTenantService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AbpTenantService,\n    factory: AbpTenantService.ɵfac,\n    providedIn: 'root'\n  });\n  return AbpTenantService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MultiTenancyService = /*#__PURE__*/(() => {\n  class MultiTenancyService {\n    constructor(restService, sessionState, tenantService, configStateService, tenantKey) {\n      this.restService = restService;\n      this.sessionState = sessionState;\n      this.tenantService = tenantService;\n      this.configStateService = configStateService;\n      this.tenantKey = tenantKey;\n      this.domainTenant = null;\n      this.isTenantBoxVisible = true;\n      this.apiName = 'abp';\n\n      this.setTenantToState = tenant => {\n        this.sessionState.setTenant({\n          id: tenant.tenantId,\n          name: tenant.name,\n          isAvailable: true\n        });\n        return this.configStateService.refreshAppState().pipe(map(_ => tenant));\n      };\n    }\n\n    setTenantByName(tenantName) {\n      return this.tenantService.findTenantByName(tenantName).pipe(switchMap(this.setTenantToState));\n    }\n\n    setTenantById(tenantId) {\n      return this.tenantService.findTenantById(tenantId).pipe(switchMap(this.setTenantToState));\n    }\n\n  }\n\n  MultiTenancyService.ɵfac = function MultiTenancyService_Factory(t) {\n    return new (t || MultiTenancyService)(i0.ɵɵinject(RestService), i0.ɵɵinject(SessionStateService), i0.ɵɵinject(AbpTenantService), i0.ɵɵinject(ConfigStateService), i0.ɵɵinject(TENANT_KEY));\n  };\n\n  MultiTenancyService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MultiTenancyService,\n    factory: MultiTenancyService.ɵfac,\n    providedIn: 'root'\n  });\n  return MultiTenancyService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst tenancyPlaceholder = '{0}';\n\nfunction getCurrentTenancyName(appBaseUrl) {\n  var _a;\n\n  if (appBaseUrl.charAt(appBaseUrl.length - 1) !== '/') appBaseUrl += '/';\n  const parseTokens = createTokenParser(appBaseUrl);\n  const token = tenancyPlaceholder.replace(/[}{]/g, '');\n  return (_a = parseTokens(window.location.href)[token]) === null || _a === void 0 ? void 0 : _a[0];\n}\n\nfunction getCurrentTenancyNameFromUrl(tenantKey) {\n  const urlParams = new URLSearchParams(window.location.search);\n  return urlParams.get(tenantKey);\n}\n\nfunction parseTenantFromUrl(injector) {\n  var _a, _b;\n\n  return __awaiter(this, void 0, void 0, function* () {\n    const environmentService = injector.get(EnvironmentService);\n    const multiTenancyService = injector.get(MultiTenancyService);\n    const baseUrl = ((_b = (_a = environmentService.getEnvironment()) === null || _a === void 0 ? void 0 : _a.application) === null || _b === void 0 ? void 0 : _b.baseUrl) || '';\n    const tenancyName = getCurrentTenancyName(baseUrl);\n\n    const hideTenantBox = () => {\n      multiTenancyService.isTenantBoxVisible = false;\n    };\n\n    const setDomainTenant = tenant => {\n      multiTenancyService.domainTenant = {\n        id: tenant.tenantId,\n        name: tenant.name,\n        isAvailable: true\n      };\n    };\n\n    const setEnvironmentWithDomainTenant = tenant => {\n      hideTenantBox();\n      setDomainTenant(tenant);\n    };\n\n    if (tenancyName) {\n      /**\r\n       * We have to replace tenant name within the urls from environment,\r\n       * because the code below will make a http request to find information about the domain tenant.\r\n       * Before this request takes place, we need to replace placeholders aka \"{0}\".\r\n       */\n      replaceTenantNameWithinEnvironment(injector, tenancyName);\n      return multiTenancyService.setTenantByName(tenancyName).pipe(tap(setEnvironmentWithDomainTenant)).toPromise();\n    } else {\n      /**\r\n       * If there is no tenant, we still have to clean up {0}. from baseUrl to avoid incorrect http requests.\r\n       */\n      replaceTenantNameWithinEnvironment(injector, '', tenancyPlaceholder + '.');\n      const tenantIdFromQueryParams = getCurrentTenancyNameFromUrl(multiTenancyService.tenantKey);\n\n      if (tenantIdFromQueryParams) {\n        return multiTenancyService.setTenantById(tenantIdFromQueryParams).toPromise();\n      }\n    }\n\n    return Promise.resolve();\n  });\n}\n\nfunction replaceTenantNameWithinEnvironment(injector, tenancyName, placeholder = tenancyPlaceholder) {\n  const environmentService = injector.get(EnvironmentService);\n  const environment = clone(environmentService.getEnvironment());\n\n  if (environment.application.baseUrl) {\n    environment.application.baseUrl = environment.application.baseUrl.replace(placeholder, tenancyName);\n  }\n\n  if (environment.oAuthConfig.redirectUri) {\n    environment.oAuthConfig.redirectUri = environment.oAuthConfig.redirectUri.replace(placeholder, tenancyName);\n  }\n\n  environment.oAuthConfig.issuer = environment.oAuthConfig.issuer.replace(placeholder, tenancyName);\n  Object.keys(environment.apis).forEach(api => {\n    Object.keys(environment.apis[api]).forEach(key => {\n      environment.apis[api][key] = environment.apis[api][key].replace(placeholder, tenancyName);\n    });\n  });\n  return environmentService.setState(environment);\n}\n\nfunction getInitialData(injector) {\n  const fn = () => __awaiter(this, void 0, void 0, function* () {\n    const environmentService = injector.get(EnvironmentService);\n    const configState = injector.get(ConfigStateService);\n    const options = injector.get(CORE_OPTIONS);\n    environmentService.setState(options.environment);\n    yield getRemoteEnv(injector, options.environment);\n    yield parseTenantFromUrl(injector);\n    yield injector.get(AuthService).init();\n    if (options.skipGetAppConfiguration) return;\n    return configState.refreshAppState().pipe(tap(() => checkAccessToken(injector)), tap(() => {\n      const currentTenant = configState.getOne('currentTenant');\n      injector.get(SessionStateService).setTenant(currentTenant);\n    }), catchError(error => {\n      const appInitErrorHandlers = injector.get(APP_INIT_ERROR_HANDLERS, null);\n\n      if (appInitErrorHandlers && appInitErrorHandlers.length) {\n        appInitErrorHandlers.forEach(func => func(error));\n      }\n\n      return throwError(error);\n    })).toPromise();\n  });\n\n  return fn;\n}\n\nfunction checkAccessToken(injector) {\n  const configState = injector.get(ConfigStateService);\n  const oAuth = injector.get(OAuthService);\n\n  if (oAuth.hasValidAccessToken() && !configState.getDeep('currentUser.id')) {\n    clearOAuthStorage();\n  }\n}\n\nfunction localeInitializer(injector) {\n  const fn = () => {\n    const sessionState = injector.get(SessionStateService);\n    const {\n      registerLocaleFn\n    } = injector.get(CORE_OPTIONS);\n    const lang = sessionState.getLanguage() || 'en';\n    return new Promise((resolve, reject) => {\n      registerLocaleFn(lang).then(module => {\n        if (module === null || module === void 0 ? void 0 : module.default) registerLocaleData(module.default);\n        return resolve('resolved');\n      }, reject);\n    });\n  };\n\n  return fn;\n}\n\nfunction getShortDateFormat(configStateService) {\n  const dateTimeFormat = configStateService.getDeep('localization.currentCulture.dateTimeFormat');\n  return dateTimeFormat.shortDatePattern;\n}\n\nfunction getShortTimeFormat(configStateService) {\n  const dateTimeFormat = configStateService.getDeep('localization.currentCulture.dateTimeFormat');\n  return dateTimeFormat.shortTimePattern.replace('tt', 'a');\n}\n\nfunction getShortDateShortTimeFormat(configStateService) {\n  const dateTimeFormat = configStateService.getDeep('localization.currentCulture.dateTimeFormat');\n  return `${dateTimeFormat.shortDatePattern} ${dateTimeFormat.shortTimePattern.replace('tt', 'a')}`;\n}\n\nlet ContentProjectionService = /*#__PURE__*/(() => {\n  class ContentProjectionService {\n    constructor(injector) {\n      this.injector = injector;\n    }\n\n    projectContent(projectionStrategy, injector = this.injector) {\n      return projectionStrategy.injectContent(injector);\n    }\n\n  }\n\n  ContentProjectionService.ɵfac = function ContentProjectionService_Factory(t) {\n    return new (t || ContentProjectionService)(i0.ɵɵinject(i0.Injector));\n  };\n\n  ContentProjectionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ContentProjectionService,\n    factory: ContentProjectionService.ɵfac,\n    providedIn: 'root'\n  });\n  return ContentProjectionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass LazyModuleFactory extends NgModuleFactory {\n  constructor(moduleWithProviders) {\n    super();\n    this.moduleWithProviders = moduleWithProviders;\n  }\n\n  get moduleType() {\n    return this.moduleWithProviders.ngModule;\n  }\n\n  create(parentInjector) {\n    const injector = Injector.create({\n      parent: parentInjector,\n      providers: this.moduleWithProviders.providers\n    });\n    const compiler = injector.get(Compiler);\n    const factory = compiler.compileModuleSync(this.moduleType);\n    return factory.create(injector);\n  }\n\n}\n\nfunction featuresFactory(configState, featureKeys, mapFn = features => features) {\n  return configState.getFeatures$(featureKeys).pipe(filter(Boolean), map(mapFn));\n}\n\nfunction downloadBlob(blob, filename) {\n  const blobUrl = URL.createObjectURL(blob);\n  const link = document.createElement('a');\n  link.href = blobUrl;\n  link.download = filename;\n  document.body.appendChild(link);\n  link.dispatchEvent(new MouseEvent('click', {\n    bubbles: true,\n    cancelable: true,\n    view: window\n  }));\n  document.body.removeChild(link);\n}\n\nfunction isNumber(value) {\n  return value == Number(value);\n}\n\nfunction mapEnumToOptions(_enum) {\n  const options = [];\n\n  for (const member in _enum) if (!isNumber(member)) options.push({\n    key: member,\n    value: _enum[member]\n  });\n\n  return options;\n}\n\nfunction uuid(a) {\n  return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ('' + 1e7 + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);\n}\n\nfunction generateHash(value) {\n  let hashed = 0;\n  let charCode;\n\n  for (let i = 0; i < value.length; i++) {\n    charCode = value.charCodeAt(i);\n    hashed = (hashed << 5) - hashed + charCode;\n    hashed |= 0;\n  }\n\n  return hashed;\n}\n\nfunction generatePassword(length = 8) {\n  length = Math.min(Math.max(4, length), 128);\n  const lowers = 'abcdefghijklmnopqrstuvwxyz';\n  const uppers = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  const numbers = '0123456789';\n  const specials = '!@#$%&*()_+{}<>?[]./';\n  const all = lowers + uppers + numbers + specials;\n\n  const getRandom = chrSet => chrSet[Math.floor(Math.random() * chrSet.length)];\n\n  const password = Array({\n    length\n  });\n  password[0] = getRandom(lowers);\n  password[1] = getRandom(uppers);\n  password[2] = getRandom(numbers);\n  password[3] = getRandom(specials);\n\n  for (let i = 4; i < length; i++) {\n    password[i] = getRandom(all);\n  }\n\n  return password.sort(() => 0.5 - Math.random()).join('');\n}\n\nclass CrossOriginStrategy {\n  constructor(crossorigin, integrity) {\n    this.crossorigin = crossorigin;\n    this.integrity = integrity;\n  }\n\n  setCrossOrigin(element) {\n    if (this.integrity) element.setAttribute('integrity', this.integrity);\n    element.setAttribute('crossorigin', this.crossorigin);\n  }\n\n}\n\nclass NoCrossOriginStrategy extends CrossOriginStrategy {\n  setCrossOrigin() {}\n\n}\n\nconst CROSS_ORIGIN_STRATEGY = {\n  Anonymous(integrity) {\n    return new CrossOriginStrategy('anonymous', integrity);\n  },\n\n  UseCredentials(integrity) {\n    return new CrossOriginStrategy('use-credentials', integrity);\n  },\n\n  None() {\n    return new NoCrossOriginStrategy(null);\n  }\n\n};\n\nclass DomStrategy {\n  constructor(target = document.head, position = 'beforeend') {\n    this.target = target;\n    this.position = position;\n  }\n\n  insertElement(element) {\n    this.target.insertAdjacentElement(this.position, element);\n  }\n\n}\n\nconst DOM_STRATEGY = {\n  AfterElement(element) {\n    return new DomStrategy(element, 'afterend');\n  },\n\n  AppendToBody() {\n    return new DomStrategy(document.body, 'beforeend');\n  },\n\n  AppendToHead() {\n    return new DomStrategy(document.head, 'beforeend');\n  },\n\n  BeforeElement(element) {\n    return new DomStrategy(element, 'beforebegin');\n  },\n\n  PrependToHead() {\n    return new DomStrategy(document.head, 'afterbegin');\n  }\n\n};\n\nfunction fromLazyLoad(element, domStrategy = DOM_STRATEGY.AppendToHead(), crossOriginStrategy = CROSS_ORIGIN_STRATEGY.Anonymous()) {\n  crossOriginStrategy.setCrossOrigin(element);\n  domStrategy.insertElement(element);\n  return new Observable(observer => {\n    element.onload = event => {\n      clearCallbacks(element);\n      observer.next(event);\n      observer.complete();\n    };\n\n    const handleError = createErrorHandler(observer, element);\n    element.onerror = handleError;\n    element.onabort = handleError;\n    element.onemptied = handleError;\n    element.onstalled = handleError;\n    element.onsuspend = handleError;\n    return () => {\n      clearCallbacks(element);\n      observer.complete();\n    };\n  });\n}\n\nfunction createErrorHandler(observer, element) {\n  return function (event) {\n    clearCallbacks(element);\n    element.parentNode.removeChild(element);\n    observer.error(event);\n  };\n}\n\nfunction clearCallbacks(element) {\n  element.onload = null;\n  element.onerror = null;\n  element.onabort = null;\n  element.onemptied = null;\n  element.onstalled = null;\n  element.onsuspend = null;\n}\n\nlet DomInsertionService = /*#__PURE__*/(() => {\n  class DomInsertionService {\n    constructor() {\n      this.inserted = new Set();\n    }\n\n    insertContent(contentStrategy) {\n      const hash = generateHash(contentStrategy.content);\n      if (this.inserted.has(hash)) return;\n      const element = contentStrategy.insertElement();\n      this.inserted.add(hash);\n      return element;\n    }\n\n    removeContent(element) {\n      const hash = generateHash(element.textContent);\n      this.inserted.delete(hash);\n      element.parentNode.removeChild(element);\n    }\n\n    has(content) {\n      const hash = generateHash(content);\n      return this.inserted.has(hash);\n    }\n\n  }\n\n  DomInsertionService.ɵfac = function DomInsertionService_Factory(t) {\n    return new (t || DomInsertionService)();\n  };\n\n  DomInsertionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DomInsertionService,\n    factory: DomInsertionService.ɵfac,\n    providedIn: 'root'\n  });\n  return DomInsertionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ResourceWaitService = /*#__PURE__*/(() => {\n  class ResourceWaitService {\n    constructor() {\n      this.store = new InternalStore({\n        resources: new Set()\n      });\n    }\n\n    getLoading() {\n      return !!this.store.state.resources.size;\n    }\n\n    getLoading$() {\n      return this.store.sliceState(({\n        resources\n      }) => !!resources.size);\n    }\n\n    updateLoading$() {\n      return this.store.sliceUpdate(({\n        resources\n      }) => !!resources.size);\n    }\n\n    clearLoading() {\n      this.store.patch({\n        resources: new Set()\n      });\n    }\n\n    addResource(resource) {\n      const resources = this.store.state.resources;\n      resources.add(resource);\n      this.store.patch({\n        resources\n      });\n    }\n\n    deleteResource(resource) {\n      const resources = this.store.state.resources;\n      resources.delete(resource);\n      this.store.patch({\n        resources\n      });\n    }\n\n  }\n\n  ResourceWaitService.ɵfac = function ResourceWaitService_Factory(t) {\n    return new (t || ResourceWaitService)();\n  };\n\n  ResourceWaitService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ResourceWaitService,\n    factory: ResourceWaitService.ɵfac,\n    providedIn: 'root'\n  });\n  return ResourceWaitService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LazyLoadService = /*#__PURE__*/(() => {\n  class LazyLoadService {\n    constructor(resourceWaitService) {\n      this.resourceWaitService = resourceWaitService;\n      this.loaded = new Map();\n    }\n\n    load(strategy, retryTimes, retryDelay) {\n      if (this.loaded.has(strategy.path)) return of(new CustomEvent('load'));\n      this.resourceWaitService.addResource(strategy.path);\n      return strategy.createStream().pipe(retryWhen(error$ => concat(error$.pipe(delay(retryDelay), take(retryTimes)), throwError(new CustomEvent('error')))), tap(() => {\n        this.loaded.set(strategy.path, strategy.element);\n        this.resourceWaitService.deleteResource(strategy.path);\n      }), delay(100), shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n\n    remove(path) {\n      const element = this.loaded.get(path);\n      if (!element) return false;\n      element.parentNode.removeChild(element);\n      this.loaded.delete(path);\n      return true;\n    }\n\n  }\n\n  LazyLoadService.ɵfac = function LazyLoadService_Factory(t) {\n    return new (t || LazyLoadService)(i0.ɵɵinject(ResourceWaitService));\n  };\n\n  LazyLoadService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LazyLoadService,\n    factory: LazyLoadService.ɵfac,\n    providedIn: 'root'\n  });\n  return LazyLoadService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst LIST_QUERY_DEBOUNCE_TIME = new InjectionToken('LIST_QUERY_DEBOUNCE_TIME');\nlet ListService = /*#__PURE__*/(() => {\n  class ListService {\n    constructor(injector) {\n      this._filter = '';\n      this._maxResultCount = 10;\n      this._skipCount = 0;\n      this._page = 0;\n      this._sortKey = '';\n      this._sortOrder = '';\n      this._query$ = new ReplaySubject(1);\n      this._isLoading$ = new BehaviorSubject(false);\n      this.destroy$ = new Subject();\n\n      this.get = () => {\n        this.resetPageWhenUnchanged();\n        this.next();\n      };\n\n      this.getWithoutPageReset = () => {\n        this.next();\n      };\n\n      const delay = injector.get(LIST_QUERY_DEBOUNCE_TIME, 300);\n      this.delay = delay ? debounceTime(delay) : tap();\n      this.get();\n    }\n\n    set filter(value) {\n      this._filter = value;\n      this.get();\n    }\n\n    get filter() {\n      return this._filter;\n    }\n\n    set maxResultCount(value) {\n      this._maxResultCount = value;\n      this.get();\n    }\n\n    get maxResultCount() {\n      return this._maxResultCount;\n    }\n\n    set page(value) {\n      if (value === this._page) return;\n      this._page = value;\n      this.get();\n    }\n\n    get page() {\n      return this._page;\n    }\n\n    set sortKey(value) {\n      this._sortKey = value;\n      this.get();\n    }\n\n    get sortKey() {\n      return this._sortKey;\n    }\n\n    set sortOrder(value) {\n      this._sortOrder = value;\n      this.get();\n    }\n\n    get sortOrder() {\n      return this._sortOrder;\n    }\n\n    get query$() {\n      return this._query$.asObservable().pipe(this.delay, shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n\n    get isLoading$() {\n      return this._isLoading$.asObservable();\n    }\n\n    hookToQuery(streamCreatorCallback) {\n      return this.query$.pipe(tap(() => this._isLoading$.next(true)), switchMap(query => streamCreatorCallback(query).pipe(catchError(() => of(null)))), filter(Boolean), tap(() => this._isLoading$.next(false)), shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }), takeUntil(this.destroy$));\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n    }\n\n    resetPageWhenUnchanged() {\n      const skipCount = this._page * this._maxResultCount;\n\n      if (skipCount === this._skipCount) {\n        this._page = 0;\n        this._skipCount = 0;\n      } else this._skipCount = skipCount;\n    }\n\n    next() {\n      this._query$.next({\n        filter: this._filter || undefined,\n        maxResultCount: this._maxResultCount,\n        skipCount: this._page * this._maxResultCount,\n        sorting: this._sortOrder ? `${this._sortKey} ${this._sortOrder}` : undefined\n      });\n    }\n\n  }\n\n  ListService.ɵfac = function ListService_Factory(t) {\n    return new (t || ListService)(i0.ɵɵinject(i0.Injector));\n  };\n\n  ListService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ListService,\n    factory: ListService.ɵfac\n  });\n  return ListService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RouterWaitService = /*#__PURE__*/(() => {\n  class RouterWaitService {\n    constructor(routerEvents, injector) {\n      this.routerEvents = routerEvents;\n      this.store = new InternalStore({\n        loading: false\n      });\n      this.destroy$ = new Subject();\n      this.delay = injector.get(LOADER_DELAY, 500);\n      this.updateLoadingStatusOnNavigationEvents();\n    }\n\n    updateLoadingStatusOnNavigationEvents() {\n      this.routerEvents.getAllNavigationEvents().pipe(map(event => event instanceof NavigationStart), switchMap(condition => condition ? this.delay === 0 ? of(true) : timer(this.delay || 0).pipe(mapTo(true), takeUntil(this.destroy$)) : of(false)), tap(() => this.destroy$.next())).subscribe(status => {\n        this.setLoading(status);\n      });\n    }\n\n    getLoading() {\n      return this.store.state.loading;\n    }\n\n    getLoading$() {\n      return this.store.sliceState(({\n        loading\n      }) => loading);\n    }\n\n    updateLoading$() {\n      return this.store.sliceUpdate(({\n        loading\n      }) => loading);\n    }\n\n    setLoading(loading) {\n      this.store.patch({\n        loading\n      });\n    }\n\n  }\n\n  RouterWaitService.ɵfac = function RouterWaitService_Factory(t) {\n    return new (t || RouterWaitService)(i0.ɵɵinject(RouterEvents), i0.ɵɵinject(i0.Injector));\n  };\n\n  RouterWaitService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RouterWaitService,\n    factory: RouterWaitService.ɵfac,\n    providedIn: 'root'\n  });\n  return RouterWaitService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst trackBy = key => (_, item) => item[key];\n\nconst trackByDeep = ( // eslint-disable-next-line @typescript-eslint/ban-types\n...keys) => (_, item) => keys.reduce((acc, key) => acc[key], item);\n\nlet TrackByService = /*#__PURE__*/(() => {\n  class TrackByService {\n    constructor() {\n      this.by = trackBy;\n      this.byDeep = trackByDeep;\n    }\n\n  }\n\n  TrackByService.ɵfac = function TrackByService_Factory(t) {\n    return new (t || TrackByService)();\n  };\n\n  TrackByService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TrackByService,\n    factory: TrackByService.ɵfac,\n    providedIn: 'root'\n  });\n  return TrackByService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ShortDateTimePipe = /*#__PURE__*/(() => {\n  class ShortDateTimePipe extends DatePipe {\n    constructor(configStateService, locale, defaultTimezone) {\n      super(locale, defaultTimezone);\n      this.configStateService = configStateService;\n    }\n\n    transform(value, timezone, locale) {\n      const format = getShortDateShortTimeFormat(this.configStateService);\n      return super.transform(value, format, timezone, locale);\n    }\n\n  }\n\n  ShortDateTimePipe.ɵfac = function ShortDateTimePipe_Factory(t) {\n    return new (t || ShortDateTimePipe)(i0.ɵɵdirectiveInject(ConfigStateService, 16), i0.ɵɵdirectiveInject(LOCALE_ID, 16), i0.ɵɵdirectiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24));\n  };\n\n  ShortDateTimePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"shortDateTime\",\n    type: ShortDateTimePipe,\n    pure: true\n  });\n  return ShortDateTimePipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ShortTimePipe = /*#__PURE__*/(() => {\n  class ShortTimePipe extends DatePipe {\n    constructor(configStateService, locale, defaultTimezone) {\n      super(locale, defaultTimezone);\n      this.configStateService = configStateService;\n    }\n\n    transform(value, timezone, locale) {\n      const format = getShortTimeFormat(this.configStateService);\n      return super.transform(value, format, timezone, locale);\n    }\n\n  }\n\n  ShortTimePipe.ɵfac = function ShortTimePipe_Factory(t) {\n    return new (t || ShortTimePipe)(i0.ɵɵdirectiveInject(ConfigStateService, 16), i0.ɵɵdirectiveInject(LOCALE_ID, 16), i0.ɵɵdirectiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24));\n  };\n\n  ShortTimePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"shortTime\",\n    type: ShortTimePipe,\n    pure: true\n  });\n  return ShortTimePipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ShortDatePipe = /*#__PURE__*/(() => {\n  class ShortDatePipe extends DatePipe {\n    constructor(configStateService, locale, defaultTimezone) {\n      super(locale, defaultTimezone);\n      this.configStateService = configStateService;\n    }\n\n    transform(value, timezone, locale) {\n      const format = getShortDateFormat(this.configStateService);\n      return super.transform(value, format, timezone, locale);\n    }\n\n  }\n\n  ShortDatePipe.ɵfac = function ShortDatePipe_Factory(t) {\n    return new (t || ShortDatePipe)(i0.ɵɵdirectiveInject(ConfigStateService, 16), i0.ɵɵdirectiveInject(LOCALE_ID, 16), i0.ɵɵdirectiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24));\n  };\n\n  ShortDatePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"shortDate\",\n    type: ShortDatePipe,\n    pure: true\n  });\n  return ShortDatePipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction storageFactory() {\n  return oAuthStorage;\n}\n/**\r\n * BaseCoreModule is the module that holds\r\n * all imports, declarations, exports, and entryComponents\r\n * but not the providers.\r\n * This module will be imported and exported by all others.\r\n */\n\n\nlet BaseCoreModule = /*#__PURE__*/(() => {\n  class BaseCoreModule {}\n\n  BaseCoreModule.ɵfac = function BaseCoreModule_Factory(t) {\n    return new (t || BaseCoreModule)();\n  };\n\n  BaseCoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: BaseCoreModule\n  });\n  BaseCoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [LocalizationPipe],\n    imports: [[OAuthModule, CommonModule, HttpClientModule, FormsModule, ReactiveFormsModule, RouterModule, LocalizationModule], CommonModule, HttpClientModule, FormsModule, ReactiveFormsModule, RouterModule, LocalizationModule]\n  });\n  return BaseCoreModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * RootCoreModule is the module that will be used at root level\r\n * and it introduces imports useful at root level (e.g. NGXS)\r\n */\n\n\nlet RootCoreModule = /*#__PURE__*/(() => {\n  class RootCoreModule {}\n\n  RootCoreModule.ɵfac = function RootCoreModule_Factory(t) {\n    return new (t || RootCoreModule)();\n  };\n\n  RootCoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: RootCoreModule\n  });\n  RootCoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[BaseCoreModule, LocalizationModule, OAuthModule, HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'RequestVerificationToken'\n    })], BaseCoreModule, LocalizationModule]\n  });\n  return RootCoreModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * CoreModule is the module that is publicly available\r\n */\n\n\nlet CoreModule = /*#__PURE__*/(() => {\n  class CoreModule {\n    static forRoot(options = {}) {\n      return {\n        ngModule: RootCoreModule,\n        providers: [OAuthModule.forRoot().providers, LocaleProvider, CookieLanguageProvider, {\n          provide: 'CORE_OPTIONS',\n          useValue: options\n        }, {\n          provide: CORE_OPTIONS,\n          useFactory: coreOptionsFactory,\n          deps: ['CORE_OPTIONS']\n        }, {\n          provide: HTTP_INTERCEPTORS,\n          useExisting: ApiInterceptor,\n          multi: true\n        }, {\n          provide: APP_INITIALIZER,\n          multi: true,\n          deps: [OAuthConfigurationHandler],\n          useFactory: noop\n        }, {\n          provide: APP_INITIALIZER,\n          multi: true,\n          deps: [Injector],\n          useFactory: getInitialData\n        }, {\n          provide: APP_INITIALIZER,\n          multi: true,\n          deps: [Injector],\n          useFactory: localeInitializer\n        }, {\n          provide: APP_INITIALIZER,\n          multi: true,\n          deps: [LocalizationService],\n          useFactory: noop\n        }, {\n          provide: APP_INITIALIZER,\n          multi: true,\n          deps: [RoutesHandler],\n          useFactory: noop\n        }, {\n          provide: OAuthStorage,\n          useFactory: storageFactory\n        }, {\n          provide: TENANT_KEY,\n          useValue: options.tenantKey || '__tenant'\n        }, {\n          provide: LOCALIZATIONS,\n          multi: true,\n          useValue: localizationContributor(options.localizations),\n          deps: [LocalizationService]\n        }]\n      };\n    }\n\n    static forChild(options = {}) {\n      return {\n        ngModule: RootCoreModule,\n        providers: [{\n          provide: LOCALIZATIONS,\n          multi: true,\n          useValue: localizationContributor(options.localizations),\n          deps: [LocalizationService]\n        }]\n      };\n    }\n\n  }\n\n  CoreModule.ɵfac = function CoreModule_Factory(t) {\n    return new (t || CoreModule)();\n  };\n\n  CoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CoreModule\n  });\n  CoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[BaseCoreModule], BaseCoreModule]\n  });\n  return CoreModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AuthGuard = /*#__PURE__*/(() => {\n  class AuthGuard {\n    constructor(oauthService, authService) {\n      this.oauthService = oauthService;\n      this.authService = authService;\n    }\n\n    canActivate() {\n      const hasValidAccessToken = this.oauthService.hasValidAccessToken();\n\n      if (hasValidAccessToken) {\n        return true;\n      }\n\n      this.authService.navigateToLogin();\n      return false;\n    }\n\n  }\n\n  AuthGuard.ɵfac = function AuthGuard_Factory(t) {\n    return new (t || AuthGuard)(i0.ɵɵinject(i1$3.OAuthService), i0.ɵɵinject(AuthService));\n  };\n\n  AuthGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthGuard,\n    factory: AuthGuard.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthGuard;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet PermissionGuard = /*#__PURE__*/(() => {\n  class PermissionGuard {\n    constructor(router, routesService, permissionService, httpErrorReporter) {\n      this.router = router;\n      this.routesService = routesService;\n      this.permissionService = permissionService;\n      this.httpErrorReporter = httpErrorReporter;\n    }\n\n    canActivate(route, state) {\n      let {\n        requiredPolicy\n      } = route.data || {};\n\n      if (!requiredPolicy) {\n        const routeFound = findRoute(this.routesService, getRoutePath(this.router, state.url));\n        requiredPolicy = routeFound === null || routeFound === void 0 ? void 0 : routeFound.requiredPolicy;\n      }\n\n      if (!requiredPolicy) return of(true);\n      return this.permissionService.getGrantedPolicy$(requiredPolicy).pipe(tap(access => {\n        if (!access) {\n          this.httpErrorReporter.reportError({\n            status: 403\n          });\n        }\n      }));\n    }\n\n  }\n\n  PermissionGuard.ɵfac = function PermissionGuard_Factory(t) {\n    return new (t || PermissionGuard)(i0.ɵɵinject(i1$1.Router), i0.ɵɵinject(RoutesService), i0.ɵɵinject(PermissionService), i0.ɵɵinject(HttpErrorReporterService));\n  };\n\n  PermissionGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PermissionGuard,\n    factory: PermissionGuard.ɵfac,\n    providedIn: 'root'\n  });\n  return PermissionGuard;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass ListResultDto {\n  constructor(initialValues = {}) {\n    for (const key in initialValues) {\n      if (Object.prototype.hasOwnProperty.call(initialValues, key)) {\n        this[key] = initialValues[key];\n      }\n    }\n  }\n\n}\n\nclass PagedResultDto extends ListResultDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass LimitedResultRequestDto {\n  constructor(initialValues = {}) {\n    this.maxResultCount = 10;\n\n    for (const key in initialValues) {\n      if (Object.prototype.hasOwnProperty.call(initialValues, key) && initialValues[key] !== undefined) {\n        this[key] = initialValues[key];\n      }\n    }\n  }\n\n}\n\nclass PagedResultRequestDto extends LimitedResultRequestDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass PagedAndSortedResultRequestDto extends PagedResultRequestDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass EntityDto {\n  constructor(initialValues = {}) {\n    for (const key in initialValues) {\n      if (Object.prototype.hasOwnProperty.call(initialValues, key)) {\n        this[key] = initialValues[key];\n      }\n    }\n  }\n\n}\n\nclass CreationAuditedEntityDto extends EntityDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass CreationAuditedEntityWithUserDto extends CreationAuditedEntityDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass AuditedEntityDto extends CreationAuditedEntityDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass AuditedEntityWithUserDto extends AuditedEntityDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass FullAuditedEntityDto extends AuditedEntityDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass FullAuditedEntityWithUserDto extends FullAuditedEntityDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass ExtensibleObject {\n  constructor(initialValues = {}) {\n    for (const key in initialValues) {\n      if (Object.prototype.hasOwnProperty.call(initialValues, key)) {\n        this[key] = initialValues[key];\n      }\n    }\n  }\n\n}\n\nclass ExtensibleEntityDto extends ExtensibleObject {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass ExtensibleCreationAuditedEntityDto extends ExtensibleEntityDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass ExtensibleAuditedEntityDto extends ExtensibleCreationAuditedEntityDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass ExtensibleAuditedEntityWithUserDto extends ExtensibleAuditedEntityDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass ExtensibleCreationAuditedEntityWithUserDto extends ExtensibleCreationAuditedEntityDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass ExtensibleFullAuditedEntityDto extends ExtensibleAuditedEntityDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nclass ExtensibleFullAuditedEntityWithUserDto extends ExtensibleFullAuditedEntityDto {\n  constructor(initialValues = {}) {\n    super(initialValues);\n  }\n\n}\n\nlet AbpApiDefinitionService = /*#__PURE__*/(() => {\n  class AbpApiDefinitionService {\n    constructor(restService) {\n      this.restService = restService;\n      this.apiName = 'abp';\n\n      this.getByModel = model => this.restService.request({\n        method: 'GET',\n        url: '/api/abp/api-definition',\n        params: {\n          includeTypes: model.includeTypes\n        }\n      }, {\n        apiName: this.apiName\n      });\n    }\n\n  }\n\n  AbpApiDefinitionService.ɵfac = function AbpApiDefinitionService_Factory(t) {\n    return new (t || AbpApiDefinitionService)(i0.ɵɵinject(RestService));\n  };\n\n  AbpApiDefinitionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AbpApiDefinitionService,\n    factory: AbpApiDefinitionService.ɵfac,\n    providedIn: 'root'\n  });\n  return AbpApiDefinitionService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nclass ContainerStrategy {\n  constructor(containerRef) {\n    this.containerRef = containerRef;\n  }\n\n  prepare() {}\n\n}\n\nclass ClearContainerStrategy extends ContainerStrategy {\n  getIndex() {\n    return 0;\n  }\n\n  prepare() {\n    this.containerRef.clear();\n  }\n\n}\n\nclass InsertIntoContainerStrategy extends ContainerStrategy {\n  constructor(containerRef, index) {\n    super(containerRef);\n    this.index = index;\n  }\n\n  getIndex() {\n    return Math.min(Math.max(0, this.index), this.containerRef.length);\n  }\n\n}\n\nconst CONTAINER_STRATEGY = {\n  Clear(containerRef) {\n    return new ClearContainerStrategy(containerRef);\n  },\n\n  Append(containerRef) {\n    return new InsertIntoContainerStrategy(containerRef, containerRef.length);\n  },\n\n  Prepend(containerRef) {\n    return new InsertIntoContainerStrategy(containerRef, 0);\n  },\n\n  Insert(containerRef, index) {\n    return new InsertIntoContainerStrategy(containerRef, index);\n  }\n\n};\n\nclass ContentSecurityStrategy {\n  constructor(nonce) {\n    this.nonce = nonce;\n  }\n\n}\n\nclass LooseContentSecurityStrategy extends ContentSecurityStrategy {\n  constructor(nonce) {\n    super(nonce);\n  }\n\n  applyCSP(element) {\n    element.setAttribute('nonce', this.nonce);\n  }\n\n}\n\nclass NoContentSecurityStrategy extends ContentSecurityStrategy {\n  constructor() {\n    super();\n  }\n\n  applyCSP(_) {}\n\n}\n\nconst CONTENT_SECURITY_STRATEGY = {\n  Loose(nonce) {\n    return new LooseContentSecurityStrategy(nonce);\n  },\n\n  None() {\n    return new NoContentSecurityStrategy();\n  }\n\n};\n\nclass ContentStrategy {\n  constructor(content, domStrategy = DOM_STRATEGY.AppendToHead(), contentSecurityStrategy = CONTENT_SECURITY_STRATEGY.None(), options = {}) {\n    this.content = content;\n    this.domStrategy = domStrategy;\n    this.contentSecurityStrategy = contentSecurityStrategy;\n    this.options = options;\n  }\n\n  insertElement() {\n    const element = this.createElement();\n\n    if (this.options && Object.keys(this.options).length > 0) {\n      Object.keys(this.options).forEach(key => element[key] = this.options[key]);\n    }\n\n    this.contentSecurityStrategy.applyCSP(element);\n    this.domStrategy.insertElement(element);\n    return element;\n  }\n\n}\n\nclass StyleContentStrategy extends ContentStrategy {\n  createElement() {\n    const element = document.createElement('style');\n    element.textContent = this.content;\n    return element;\n  }\n\n}\n\nclass ScriptContentStrategy extends ContentStrategy {\n  createElement() {\n    const element = document.createElement('script');\n    element.textContent = this.content;\n    return element;\n  }\n\n}\n\nconst CONTENT_STRATEGY = {\n  AppendScriptToBody(content, options) {\n    return new ScriptContentStrategy(content, DOM_STRATEGY.AppendToBody(), undefined, options);\n  },\n\n  AppendScriptToHead(content, options) {\n    return new ScriptContentStrategy(content, DOM_STRATEGY.AppendToHead(), undefined, options);\n  },\n\n  AppendStyleToHead(content, options) {\n    return new StyleContentStrategy(content, DOM_STRATEGY.AppendToHead(), undefined, options);\n  },\n\n  PrependStyleToHead(content, options) {\n    return new StyleContentStrategy(content, DOM_STRATEGY.PrependToHead(), undefined, options);\n  }\n\n};\n\nclass ContextStrategy {\n  constructor(context) {\n    this.context = context;\n  }\n\n  setContext(componentRef) {\n    return this.context;\n  }\n\n}\n\nclass NoContextStrategy extends ContextStrategy {\n  constructor() {\n    super(undefined);\n  }\n\n}\n\nclass ComponentContextStrategy extends ContextStrategy {\n  setContext(componentRef) {\n    Object.keys(this.context).forEach(key => componentRef.instance[key] = this.context[key]);\n    componentRef.changeDetectorRef.detectChanges();\n    return this.context;\n  }\n\n}\n\nclass TemplateContextStrategy extends ContextStrategy {\n  setContext() {\n    return this.context;\n  }\n\n}\n\nconst CONTEXT_STRATEGY = {\n  None() {\n    return new NoContextStrategy();\n  },\n\n  Component(context) {\n    return new ComponentContextStrategy(context);\n  },\n\n  Template(context) {\n    return new TemplateContextStrategy(context);\n  }\n\n};\n\nclass LoadingStrategy {\n  constructor(path, domStrategy = DOM_STRATEGY.AppendToHead(), crossOriginStrategy = CROSS_ORIGIN_STRATEGY.Anonymous()) {\n    this.path = path;\n    this.domStrategy = domStrategy;\n    this.crossOriginStrategy = crossOriginStrategy;\n  }\n\n  createStream() {\n    this.element = this.createElement();\n    return of(null).pipe(switchMap(() => fromLazyLoad(this.element, this.domStrategy, this.crossOriginStrategy)));\n  }\n\n}\n\nclass ScriptLoadingStrategy extends LoadingStrategy {\n  constructor(src, domStrategy, crossOriginStrategy) {\n    super(src, domStrategy, crossOriginStrategy);\n  }\n\n  createElement() {\n    const element = document.createElement('script');\n    element.src = this.path;\n    return element;\n  }\n\n}\n\nclass StyleLoadingStrategy extends LoadingStrategy {\n  constructor(href, domStrategy, crossOriginStrategy) {\n    super(href, domStrategy, crossOriginStrategy);\n  }\n\n  createElement() {\n    const element = document.createElement('link');\n    element.rel = 'stylesheet';\n    element.href = this.path;\n    return element;\n  }\n\n}\n\nconst LOADING_STRATEGY = {\n  AppendScriptToBody(src) {\n    return new ScriptLoadingStrategy(src, DOM_STRATEGY.AppendToBody(), CROSS_ORIGIN_STRATEGY.None());\n  },\n\n  AppendAnonymousScriptToBody(src, integrity) {\n    return new ScriptLoadingStrategy(src, DOM_STRATEGY.AppendToBody(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));\n  },\n\n  AppendAnonymousScriptToHead(src, integrity) {\n    return new ScriptLoadingStrategy(src, DOM_STRATEGY.AppendToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));\n  },\n\n  AppendAnonymousStyleToHead(src, integrity) {\n    return new StyleLoadingStrategy(src, DOM_STRATEGY.AppendToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));\n  },\n\n  PrependAnonymousScriptToHead(src, integrity) {\n    return new ScriptLoadingStrategy(src, DOM_STRATEGY.PrependToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));\n  },\n\n  PrependAnonymousStyleToHead(src, integrity) {\n    return new StyleLoadingStrategy(src, DOM_STRATEGY.PrependToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));\n  }\n\n};\n\nclass ProjectionStrategy {\n  constructor(content) {\n    this.content = content;\n  }\n\n}\n\nclass ComponentProjectionStrategy extends ProjectionStrategy {\n  constructor(component, containerStrategy, contextStrategy = CONTEXT_STRATEGY.None()) {\n    super(component);\n    this.containerStrategy = containerStrategy;\n    this.contextStrategy = contextStrategy;\n  }\n\n  injectContent(injector) {\n    this.containerStrategy.prepare();\n    const resolver = injector.get(ComponentFactoryResolver);\n    const factory = resolver.resolveComponentFactory(this.content);\n    const componentRef = this.containerStrategy.containerRef.createComponent(factory, this.containerStrategy.getIndex(), injector);\n    this.contextStrategy.setContext(componentRef);\n    return componentRef;\n  }\n\n}\n\nclass RootComponentProjectionStrategy extends ProjectionStrategy {\n  constructor(component, contextStrategy = CONTEXT_STRATEGY.None(), domStrategy = DOM_STRATEGY.AppendToBody()) {\n    super(component);\n    this.contextStrategy = contextStrategy;\n    this.domStrategy = domStrategy;\n  }\n\n  injectContent(injector) {\n    const appRef = injector.get(ApplicationRef);\n    const resolver = injector.get(ComponentFactoryResolver);\n    const componentRef = resolver.resolveComponentFactory(this.content).create(injector);\n    this.contextStrategy.setContext(componentRef);\n    appRef.attachView(componentRef.hostView);\n    const element = componentRef.hostView.rootNodes[0];\n    this.domStrategy.insertElement(element);\n    return componentRef;\n  }\n\n}\n\nclass TemplateProjectionStrategy extends ProjectionStrategy {\n  constructor(templateRef, containerStrategy, contextStrategy = CONTEXT_STRATEGY.None()) {\n    super(templateRef);\n    this.containerStrategy = containerStrategy;\n    this.contextStrategy = contextStrategy;\n  }\n\n  injectContent() {\n    this.containerStrategy.prepare();\n    const embeddedViewRef = this.containerStrategy.containerRef.createEmbeddedView(this.content, this.contextStrategy.context, this.containerStrategy.getIndex());\n    embeddedViewRef.detectChanges();\n    return embeddedViewRef;\n  }\n\n}\n\nconst PROJECTION_STRATEGY = {\n  AppendComponentToBody(component, context) {\n    return new RootComponentProjectionStrategy(component, context && CONTEXT_STRATEGY.Component(context));\n  },\n\n  AppendComponentToContainer(component, containerRef, context) {\n    return new ComponentProjectionStrategy(component, CONTAINER_STRATEGY.Append(containerRef), context && CONTEXT_STRATEGY.Component(context));\n  },\n\n  AppendTemplateToContainer(templateRef, containerRef, context) {\n    return new TemplateProjectionStrategy(templateRef, CONTAINER_STRATEGY.Append(containerRef), context && CONTEXT_STRATEGY.Template(context));\n  },\n\n  PrependComponentToContainer(component, containerRef, context) {\n    return new ComponentProjectionStrategy(component, CONTAINER_STRATEGY.Prepend(containerRef), context && CONTEXT_STRATEGY.Component(context));\n  },\n\n  PrependTemplateToContainer(templateRef, containerRef, context) {\n    return new TemplateProjectionStrategy(templateRef, CONTAINER_STRATEGY.Prepend(containerRef), context && CONTEXT_STRATEGY.Template(context));\n  },\n\n  ProjectComponentToContainer(component, containerRef, context) {\n    return new ComponentProjectionStrategy(component, CONTAINER_STRATEGY.Clear(containerRef), context && CONTEXT_STRATEGY.Component(context));\n  },\n\n  ProjectTemplateToContainer(templateRef, containerRef, context) {\n    return new TemplateProjectionStrategy(templateRef, CONTAINER_STRATEGY.Clear(containerRef), context && CONTEXT_STRATEGY.Template(context));\n  }\n\n};\nconst NAVIGATE_TO_MANAGE_PROFILE = new InjectionToken('NAVIGATE_TO_MANAGE_PROFILE', {\n  providedIn: 'root',\n  factory: () => {\n    const environment = inject(EnvironmentService);\n    return () => {\n      window.open(`${environment.getEnvironment().oAuthConfig.issuer}/Account/Manage?returnUrl=${window.location.href}`, '_self');\n    };\n  }\n});\n\nfunction validateMinAge({\n  age = 18\n} = {}) {\n  return control => {\n    if (['', null, undefined].indexOf(control.value) > -1) return null;\n    return isValidMinAge(control.value, age) ? null : {\n      minAge: {\n        age\n      }\n    };\n  };\n}\n\nfunction isValidMinAge(value, minAge) {\n  const date = new Date();\n  date.setFullYear(date.getFullYear() - minAge);\n  date.setHours(23, 59, 59, 999);\n  return Number(new Date(value)) <= date.valueOf();\n}\n\nfunction validateCreditCard() {\n  return control => {\n    if (['', null, undefined].indexOf(control.value) > -1) return null;\n    return isValidCreditCard(String(control.value)) ? null : {\n      creditCard: true\n    };\n  };\n}\n\nfunction isValidCreditCard(value) {\n  value = value.replace(/[ -]/g, '');\n  if (!/^[0-9]{13,19}$/.test(value)) return false;\n  let checksum = 0;\n  let multiplier = 1;\n\n  for (let i = value.length; i > 0; i--) {\n    const digit = Number(value[i - 1]) * multiplier;\n    checksum += digit % 10 + ~~(digit / 10);\n    multiplier = multiplier * 2 % 3;\n  }\n\n  return checksum % 10 === 0;\n}\n\nfunction validateRange({\n  maximum = Infinity,\n  minimum = 0\n} = {}) {\n  return control => {\n    if (['', null, undefined].indexOf(control.value) > -1) return null;\n    const value = Number(control.value);\n    return getMinError(value, minimum, maximum) || getMaxError(value, maximum, minimum);\n  };\n}\n\nfunction getMaxError(value, max, min) {\n  return value > max ? {\n    range: {\n      max,\n      min\n    }\n  } : null;\n}\n\nfunction getMinError(value, min, max) {\n  return value < min ? {\n    range: {\n      min,\n      max\n    }\n  } : null;\n}\n\nfunction validateRequired({\n  allowEmptyStrings\n} = {}) {\n  return control => {\n    return isValidRequired(control.value, allowEmptyStrings) ? null : {\n      required: true\n    };\n  };\n}\n\nfunction isValidRequired(value, allowEmptyStrings) {\n  if (value || value === 0 || value === false) return true;\n  if (allowEmptyStrings && value === '') return true;\n  return false;\n}\n\nfunction validateStringLength({\n  maximumLength = Infinity,\n  minimumLength = 0\n} = {}) {\n  return control => {\n    if (['', null, undefined].indexOf(control.value) > -1) return null;\n    const value = String(control.value);\n    return getMinLengthError(value, minimumLength) || getMaxLengthError(value, maximumLength);\n  };\n}\n\nfunction getMaxLengthError(value, requiredLength) {\n  return value.length > requiredLength ? {\n    maxlength: {\n      requiredLength\n    }\n  } : null;\n}\n\nfunction getMinLengthError(value, requiredLength) {\n  return value.length < requiredLength ? {\n    minlength: {\n      requiredLength\n    }\n  } : null;\n}\n\nfunction validateUrl() {\n  return control => {\n    if (['', null, undefined].indexOf(control.value) > -1) return null;\n    return isValidUrl(control.value) ? null : {\n      url: true\n    };\n  };\n}\n\nfunction isValidUrl(value) {\n  if (/^http(s)?:\\/\\/[^/]/.test(value) || /^ftp:\\/\\/[^/]/.test(value)) {\n    const a = document.createElement('a');\n    a.href = value;\n    return !!a.host;\n  }\n\n  return false;\n}\n\nconst AbpValidators = {\n  creditCard: validateCreditCard,\n  emailAddress: () => Validators.email,\n  minAge: validateMinAge,\n  range: validateRange,\n  required: validateRequired,\n  stringLength: validateStringLength,\n  url: validateUrl\n}; // export * from './lib/handlers';\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { APP_INIT_ERROR_HANDLERS, AbpApiDefinitionService, AbpApplicationConfigurationService, AbpTenantService, AbpValidators, AbstractNavTreeService, AbstractNgModelComponent, AbstractTreeService, ApiInterceptor, AuditedEntityDto, AuditedEntityWithUserDto, AuthGuard, AuthService, AutofocusDirective, BaseCoreModule, BaseTreeNode, CONTAINER_STRATEGY, CONTENT_SECURITY_STRATEGY, CONTENT_STRATEGY, CONTEXT_STRATEGY, COOKIE_LANGUAGE_KEY, CORE_OPTIONS, CROSS_ORIGIN_STRATEGY, ClearContainerStrategy, ComponentContextStrategy, ComponentProjectionStrategy, ConfigStateService, ContainerStrategy, ContentProjectionService, ContentSecurityStrategy, ContentStrategy, ContextStrategy, CoreModule, CreationAuditedEntityDto, CreationAuditedEntityWithUserDto, CrossOriginStrategy, DOM_STRATEGY, DomInsertionService, DomStrategy, DynamicLayoutComponent, EntityDto, EnvironmentService, ExtensibleAuditedEntityDto, ExtensibleAuditedEntityWithUserDto, ExtensibleCreationAuditedEntityDto, ExtensibleCreationAuditedEntityWithUserDto, ExtensibleEntityDto, ExtensibleFullAuditedEntityDto, ExtensibleFullAuditedEntityWithUserDto, ExtensibleObject, ForDirective, FormSubmitDirective, FullAuditedEntityDto, FullAuditedEntityWithUserDto, HttpErrorReporterService, HttpWaitService, INJECTOR_PIPE_DATA_TOKEN, InitDirective, InputEventDebounceDirective, InsertIntoContainerStrategy, InternalStore, LIST_QUERY_DEBOUNCE_TIME, LOADER_DELAY, LOADING_STRATEGY, LOCALIZATIONS, LazyLoadService, LazyModuleFactory, LimitedResultRequestDto, ListResultDto, ListService, LoadingStrategy, LocalizationModule, LocalizationPipe, LocalizationService, LooseContentSecurityStrategy, MultiTenancyService, NAVIGATE_TO_MANAGE_PROFILE, NavigationEvent, NoContentSecurityStrategy, NoContextStrategy, NoCrossOriginStrategy, index as ObjectExtending, PROJECTION_STRATEGY, PagedAndSortedResultRequestDto, PagedResultDto, PagedResultRequestDto, PermissionDirective, PermissionGuard, PermissionService, ProjectionStrategy, ReplaceableComponentsService, ReplaceableRouteContainerComponent, ReplaceableTemplateDirective, ResourceWaitService, RestService, RootComponentProjectionStrategy, RootCoreModule, RouterEvents, RouterOutletComponent, RouterWaitService, RoutesService, ScriptContentStrategy, ScriptLoadingStrategy, SessionStateService, ShortDatePipe, ShortDateTimePipe, ShortTimePipe, SortPipe, StopPropagationDirective, StyleContentStrategy, StyleLoadingStrategy, SubscriptionService, TENANT_KEY, TemplateContextStrategy, TemplateProjectionStrategy, ToInjectorPipe, TrackByService, WebHttpUrlEncodingCodec, checkAccessToken, coreOptionsFactory, createLocalizationPipeKeyGenerator, createLocalizer, createLocalizerWithFallback, createMapFromList, createTokenParser, createTreeFromList, createTreeNodeFilterCreator, deepMerge, differentLocales, downloadBlob, escapeHtmlChars, exists, featuresFactory, findRoute, fromLazyLoad, generateHash, generatePassword, getInitialData, getLocaleDirection, getPathName, getRemoteEnv, getRoutePath, getShortDateFormat, getShortDateShortTimeFormat, getShortTimeFormat, interpolate, isArray, isNode, isNullOrUndefined, isNumber, isObject, isObjectAndNotArray, isObjectAndNotArrayNotNode, isUndefinedOrEmptyString, localeInitializer, localizationContributor, localizations$, mapEnumToOptions, noop, parseTenantFromUrl, pipeToLogin, pushValueTo, reloadRoute, removeRememberMe, setRememberMe, setTokenResponseToStorage, storageFactory, trackBy, trackByDeep, uuid, validateCreditCard, validateMinAge, validateRange, validateRequired, validateStringLength, validateUrl }; //# sourceMappingURL=abp-ng.core.mjs.map","map":null,"metadata":{},"sourceType":"module"}